<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<title>Using Retriever Augmented Large Language Models for Attack Graph Generation</title>
<!--Generated on Sun Aug 11 19:57:54 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/ar5iv-fonts.0.7.9.min.css" rel="stylesheet" type="text/css"/>
<link href="/static/browse/0.3.4/css/latexml_styles.css" rel="stylesheet" type="text/css"/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.3/html2canvas.min.js"></script>
<script src="/static/browse/0.3.4/js/addons_new.js"></script>
<script src="/static/browse/0.3.4/js/feedbackOverlay.js"></script>
<base href="/html/2408.05855v1/"/></head>
<body>
<nav class="ltx_page_navbar">
<nav class="ltx_TOC">
<ol class="ltx_toclist">
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S1" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">1 </span>Introduction</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2 </span>Background</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.SS1" title="In 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.1 </span>CVE</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.SS2" title="In 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">2.2 </span>Attack Graph</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3 </span>Proposed System</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.SS1" title="In 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.1 </span>Pre-Processor</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.SS2" title="In 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.2 </span>Retriever</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.SS3" title="In 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.3 </span>LLM Handler</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.SS4" title="In 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">3.4 </span>Post-Processor</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S4" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">4 </span>Implementation</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section">
<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5 </span>Results</span></a>
<ol class="ltx_toclist ltx_toclist_section">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS1" title="In 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.1 </span>Effect of Context Information in Prompt</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS2" title="In 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.2 </span>Attack Graph from a Threat Report</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection">
<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS3" title="In 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.3 </span>Comparison among Different LLMs</span></a>
<ol class="ltx_toclist ltx_toclist_subsection">
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS3.SSS1" title="In 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.3.1 </span>Attack Graph from Vulnerability Information</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsubsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS3.SSS2" title="In 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.3.2 </span>Attack Graph from Threat Report</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.SS4" title="In 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">5.4 </span>Attempts on Expanding the Attack Graph Gradually</span></a></li>
</ol>
</li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S6" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">6 </span>Related Work</span></a></li>
<li class="ltx_tocentry ltx_tocentry_section"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S7" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">7 </span>Conclusion</span></a></li>
<li class="ltx_tocentry ltx_tocentry_appendix"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A1" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">A </span>Prompt for Attack Graph of Defined System</span></a></li>
<li class="ltx_tocentry ltx_tocentry_appendix"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A2" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">B </span>Prompt for Attack Graph from Kubernetes Cluster Hacked Threat Report</span></a></li>
<li class="ltx_tocentry ltx_tocentry_appendix">
<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A3" title="In Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">C </span>Prompt for Attack Graph from SolarWinds Attack Threat Report</span></a>
<ol class="ltx_toclist ltx_toclist_appendix">
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A3.SS1" title="In Appendix C Prompt for Attack Graph from SolarWinds Attack Threat Report ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">C.1 </span>Full Report</span></a></li>
<li class="ltx_tocentry ltx_tocentry_subsection"><a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A3.SS2" title="In Appendix C Prompt for Attack Graph from SolarWinds Attack Threat Report ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_title"><span class="ltx_tag ltx_tag_ref">C.2 </span>Evasion Techniques</span></a></li>
</ol>
</li>
</ol></nav>
</nav>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line ltx_leqno">
<h1 class="ltx_title ltx_title_document">Using Retriever Augmented Large Language Models for Attack Graph Generation</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Renascence Tarafder Prapty
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation">University of California Irvine
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:rprapty@uci.edu">rprapty@uci.edu</a>
</span></span></span>
<span class="ltx_author_before">, </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Ashish Kundu
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation">Cisco Research
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:ashkundu@cisco.com">ashkundu@cisco.com</a>
</span></span></span>
<span class="ltx_author_before"> and </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Arun Iyengar
</span><span class="ltx_author_notes">
<span class="ltx_contact ltx_role_affiliation">Cisco Research
</span>
<span class="ltx_contact ltx_role_email"><a href="mailto:ariyenga@cisco.com">ariyenga@cisco.com</a>
</span></span></span>
</div>
<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract.</h6>
<p class="ltx_p" id="id1.id1">As the complexity of modern systems increases, so does the importance of assessing their security posture through effective vulnerability management and threat modeling techniques. One powerful tool in the arsenal of cybersecurity professionals is the attack graph, a representation of all potential attack paths within a system that an adversary might exploit to achieve a certain objective. Traditional methods of generating attack graphs involve expert knowledge, manual curation, and computational algorithms that might not cover the entire threat landscape due to the ever-evolving nature of vulnerabilities and exploits. This paper explores the approach of leveraging large language models (LLMs), such as ChatGPT, to automate the generation of attack graphs by intelligently chaining Common Vulnerabilities and Exposures (CVEs) based on their preconditions and effects. It also shows how to utilize LLMs to create attack graphs from threat reports.</p>
</div>
<section class="ltx_section" id="S1">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1. </span>Introduction</h2>
<div class="ltx_para" id="S1.p1">
<p class="ltx_p" id="S1.p1.1">Attack graphs provide a comprehensive view of multiple attack vectors that a malicious actor could exploit to compromise system security. They are crucial tools for security analysts, enabling the understanding and visualization of potential attack paths in a system. Traditionally, constructing attack graphs has been a largely manual and time-consuming process requiring extensive expertise in cybersecurity. Automated techniques exist but they often rely on static rules or heuristics which cannot adapt to the ever-changing landscape of vulnerabilities and threats. Some existing approaches <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib1" title="">al2019a2g2v, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib2" title="">sheyner2002automated, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib3" title="">ou2006scalable, </a>)</cite> rely on static formal definitions and model checking algorithms to generate attack graphs. However, these methods are domain-specific and cannot be applied to emerging attack vectors. Furthermore, they require manual input of vulnerability information, which is not desirable since new vulnerabilities are continually discovered, and attack graphs should be updated promptly with this information. A new approach <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib4" title="">payne2019secure, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib5" title="">bezawada2019agbuilder, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib6" title="">husari2017ttpdrill, </a>)</cite> for automatic attack graph generation involves using natural language processing (NLP) techniques and machine learning models. This method uses NLP to extract different properties from vulnerability information found in a public database called the Common Vulnerabilities and Exposures (CVE). The extracted properties are utilized to create attack paths by chaining different CVEs. However, traditional machine learning models require an extensive training phase, which is a non-trivial task.</p>
</div>
<div class="ltx_para" id="S1.p2">
<p class="ltx_p" id="S1.p2.1">In recent years, advances in machine learning have presented new avenues for solving complex problems. Large language models (LLMs) like GPT-4, trained on diverse data sources, have demonstrated significant capabilities in natural language understanding and generation. These models have been applied successfully across a variety of domains, including translation, summarization, and question-answering among others. A natural question is how LLMs can be applied to the cybersecurity domain, specifically for generating attack graphs.</p>
</div>
<div class="ltx_para" id="S1.p3">
<p class="ltx_p" id="S1.p3.1">The aim of this paper is to investigate the potential of using large language models such as ChatGPT for automating the generation of attack graphs. Our approach leverages LLM capabilities to understand and chain Common Vulnerabilities and Exposures (CVEs) based on their preconditions and postconditions. By interpreting CVE descriptions and associated metadata, LLMs can generate links between vulnerabilities, offering a dynamic way to visualize possible attack vectors. In addition, this paper explores using LLMs for generating attack graphs based on textual threat reports, which are often rich sources of data but require manual analysis to transform into actionable insights.</p>
</div>
<div class="ltx_para" id="S1.p4">
<p class="ltx_p" id="S1.p4.1">Our work makes several contributions:</p>
<ul class="ltx_itemize" id="S1.I1">
<li class="ltx_item" id="S1.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S1.I1.i1.p1">
<p class="ltx_p" id="S1.I1.i1.p1.3">We present <math alttext="\sf{CrystalBall}" class="ltx_Math" display="inline" id="S1.I1.i1.p1.1.m1.1"><semantics id="S1.I1.i1.p1.1.m1.1a"><mi id="S1.I1.i1.p1.1.m1.1.1" xref="S1.I1.i1.p1.1.m1.1.1.cmml">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</mi><annotation-xml encoding="MathML-Content" id="S1.I1.i1.p1.1.m1.1b"><ci id="S1.I1.i1.p1.1.m1.1.1.cmml" xref="S1.I1.i1.p1.1.m1.1.1">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.I1.i1.p1.1.m1.1c">\sf{CrystalBall}</annotation><annotation encoding="application/x-llamapun" id="S1.I1.i1.p1.1.m1.1d">sansserif_CrystalBall</annotation></semantics></math>, a novel method for automated attack graph generation using retriever-augmented large language models. <math alttext="\sf{CrystalBall}" class="ltx_Math" display="inline" id="S1.I1.i1.p1.2.m2.1"><semantics id="S1.I1.i1.p1.2.m2.1a"><mi id="S1.I1.i1.p1.2.m2.1.1" xref="S1.I1.i1.p1.2.m2.1.1.cmml">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</mi><annotation-xml encoding="MathML-Content" id="S1.I1.i1.p1.2.m2.1b"><ci id="S1.I1.i1.p1.2.m2.1.1.cmml" xref="S1.I1.i1.p1.2.m2.1.1">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.I1.i1.p1.2.m2.1c">\sf{CrystalBall}</annotation><annotation encoding="application/x-llamapun" id="S1.I1.i1.p1.2.m2.1d">sansserif_CrystalBall</annotation></semantics></math> is designed to automatically generate attack graphs in a scalable manner. <math alttext="\sf{CrystalBall}" class="ltx_Math" display="inline" id="S1.I1.i1.p1.3.m3.1"><semantics id="S1.I1.i1.p1.3.m3.1a"><mi id="S1.I1.i1.p1.3.m3.1.1" xref="S1.I1.i1.p1.3.m3.1.1.cmml">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</mi><annotation-xml encoding="MathML-Content" id="S1.I1.i1.p1.3.m3.1b"><ci id="S1.I1.i1.p1.3.m3.1.1.cmml" xref="S1.I1.i1.p1.3.m3.1.1">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.I1.i1.p1.3.m3.1c">\sf{CrystalBall}</annotation><annotation encoding="application/x-llamapun" id="S1.I1.i1.p1.3.m3.1d">sansserif_CrystalBall</annotation></semantics></math> is able to handle significant amounts of unstructured text data as well as structured data.</p>
</div>
</li>
<li class="ltx_item" id="S1.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S1.I1.i2.p1">
<p class="ltx_p" id="S1.I1.i2.p1.1">To that purpose, we design a new retriever model using retriever augmented generation technique (RAG) for correct and precise extraction of relevant CVEs based on the system information.</p>
</div>
</li>
<li class="ltx_item" id="S1.I1.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S1.I1.i3.p1">
<p class="ltx_p" id="S1.I1.i3.p1.1">We develop a semantic search capable structured database to support the retriever.</p>
</div>
</li>
<li class="ltx_item" id="S1.I1.i4" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S1.I1.i4.p1">
<p class="ltx_p" id="S1.I1.i4.p1.1">We compare the performances of different LLMS for generating attack graphs.</p>
</div>
</li>
<li class="ltx_item" id="S1.I1.i5" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S1.I1.i5.p1">
<p class="ltx_p" id="S1.I1.i5.p1.1">We evaluate the performances of different LLMS on creating attack graphs from threat reports as well.</p>
</div>
</li>
</ul>
</div>
<div class="ltx_para" id="S1.p5">
<p class="ltx_p" id="S1.p5.1">This research not only offers a promising avenue for improving the efficiency and accuracy of attack graph generation but also provides insights into the broader applicability of large language models in cybersecurity.</p>
</div>
</section>
<section class="ltx_section" id="S2">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2. </span>Background</h2>
<section class="ltx_subsection" id="S2.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.1. </span>CVE</h3>
<div class="ltx_para" id="S2.SS1.p1">
<p class="ltx_p" id="S2.SS1.p1.1">Common Vulnerabilities and Exposures (CVE) <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib7" title="">cve, </a>)</cite> is a database of publicly disclosed information security issues which is maintained by the MITRE corporation <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib8" title="">mitre, </a>)</cite>. Each vulnerability entry of the database is also referred to as a CVE. All published CVEs are available in JSON Format in a github repository <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib9" title="">cve_repo, </a>)</cite>. Important properties of a CVE are CVE ID, State, and Description. CVE ID is a unique, alphanumeric identifier that uniquely identifies a specific vulnerability (CVE) from the database. CVE record or description is the descriptive data about a Vulnerability associated with a CVE ID.</p>
</div>
<div class="ltx_para" id="S2.SS1.p2">
<p class="ltx_p" id="S2.SS1.p2.1">CVE record has a semi-structured format. It represents a natural language description of the vulnerability. However, the description is bound to contain certain information i.e. product name, affected platform, affected version name etc. It also contains precondition and postcondition of the vulnerability. Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.F1" title="Figure 1 ‣ 2.1. CVE ‣ 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">1</span></a> illustrates its semi-structured nature.</p>
</div>
<figure class="ltx_figure" id="S2.F1"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="234" id="S2.F1.g1" src="extracted/5784329/figures/CVE_Description.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1. </span>Semi-structured format of a CVE record description</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S2.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.2. </span>Attack Graph</h3>
<div class="ltx_para" id="S2.SS2.p1">
<p class="ltx_p" id="S2.SS2.p1.1">An attack graph is a model for the representation of all potential attack paths in a system. It supports a visualization model and shows how attackers can exploit different vulnerabilities, and chain the vulnerabilities together to achieve attack goals. Attack graphs are helpful in understanding the potential attack paths attackers can take and prioritizing security efforts. Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.F2" title="Figure 2 ‣ 2.2. Attack Graph ‣ 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">2</span></a> shows an example attack graph. The prompt for this graph is available at Appendix <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A3.SS1" title="C.1. Full Report ‣ Appendix C Prompt for Attack Graph from SolarWinds Attack Threat Report ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">C.1</span></a>.</p>
</div>
<figure class="ltx_figure" id="S2.F2"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="337" id="S2.F2.g1" src="extracted/5784329/figures/SolarwindsAttack.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2. </span>Atttack Graph constructed from threat report of SolarWinds Supply Chain Compromise Incident</figcaption>
</figure>
</section>
</section>
<section class="ltx_section" id="S3">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3. </span>Proposed System</h2>
<div class="ltx_para" id="S3.p1">
<p class="ltx_p" id="S3.p1.1">We propose retriever-augmented generation using large language models(LLM) to generate attack graphs. Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.F3" title="Figure 3 ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">3</span></a> shows an overview of the proposed system. There are four main components in the system:</p>
</div>
<div class="ltx_para" id="S3.p2">
<ul class="ltx_itemize" id="S3.I1">
<li class="ltx_item" id="S3.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S3.I1.i1.p1">
<p class="ltx_p" id="S3.I1.i1.p1.1"><span class="ltx_text ltx_font_bold" id="S3.I1.i1.p1.1.1">Input</span>: Users can utilize our system to create attack graphs from either threat reports or CVE descriptions. In the case of CVE descriptions, users provide the target product/package name in the query. Retriever-augmented generation is used to obtain CVEs related to a user’s query. Then these CVEs are used to create context for the prompt to the LLM. In case of a threat report, a path to the threat report text file is given in the query.</p>
</div>
</li>
<li class="ltx_item" id="S3.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S3.I1.i2.p1">
<p class="ltx_p" id="S3.I1.i2.p1.1"><span class="ltx_text ltx_font_bold" id="S3.I1.i2.p1.1.1">Database</span>: The proposed system utilizes a relational database that stores CVE records, related metadata, and generated attack graphs. This database can be searched using semantic similarity. Details about this semantic search process is available in Section <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.SS2" title="3.2. Retriever ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">3.2</span></a></p>
</div>
</li>
<li class="ltx_item" id="S3.I1.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S3.I1.i3.p1">
<p class="ltx_p" id="S3.I1.i3.p1.1"><span class="ltx_text ltx_font_bold" id="S3.I1.i3.p1.1.1">Attack Graph Generator</span>: This is the main component of the system which is responsible for handling user requests. It communicates with database to create prompts and with LLMs to obtain actual attack graphs. This module is described in detail later in the section.</p>
</div>
</li>
<li class="ltx_item" id="S3.I1.i4" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S3.I1.i4.p1">
<p class="ltx_p" id="S3.I1.i4.p1.1"><span class="ltx_text ltx_font_bold" id="S3.I1.i4.p1.1.1">LLM</span>: LLM is used as a black box in the system. It is responsible for creating the attack graphs from the information provided in the prompt.</p>
</div>
</li>
</ul>
</div>
<figure class="ltx_figure" id="S3.F3"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="248" id="S3.F3.g1" src="extracted/5784329/figures/System_Model_Input.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3. </span>Proposed System Model</figcaption>
</figure>
<div class="ltx_para" id="S3.p3">
<p class="ltx_p" id="S3.p3.1">Next we describe Attack Graph Generator module in details. It has four main parts: 1. Pre-Processor, 2. Retriever, 3. LLM Handler, 4. Post-Processor.</p>
</div>
<section class="ltx_subsection" id="S3.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1. </span>Pre-Processor</h3>
<div class="ltx_para" id="S3.SS1.p1">
<p class="ltx_p" id="S3.SS1.p1.1">Pre-Processor is responsible for processing the user input. In case of threat reports, Pre-Processor reads the report text using the input path and passes it as context to the LLM handler. On the other hand, when product names are given as queries to build an attack graph from CVE descriptions, Pre-Processor obtains the embeddings of each product name and provides these embeddings to the Retriever.</p>
</div>
</section>
<section class="ltx_subsection" id="S3.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2. </span>Retriever</h3>
<div class="ltx_para" id="S3.SS2.p1">
<p class="ltx_p" id="S3.SS2.p1.1">Retrievers use either keyword matching or cosine similarity between embeddings from CVE information and user queries to find relevant CVEs. Special attention is required in determining which information from a CVE to use for embeddings. Traditional methods use embeddings of a whole CVE description. However, this results in low cosine similarity between the cve and query embedding. We observer that cosine similarity is inversely proportional to the length of CVE descriptions. If we keep the threshold of cosine similarity high for a CVE to be considered relevant, we risk missing related CVEs with long descriptions. On the other hand, choosing a low cosine similarity threshold results in extracting CVEs which are not actually related.</p>
</div>
<div class="ltx_para" id="S3.SS2.p2">
<p class="ltx_p" id="S3.SS2.p2.1">Another issue is the granularity of the selection criteria. Some vulnerabilities might affect products of one specific platform only, e.g. a product running on Linux but not on Windows. A similar situation exists for the version number. Only specific versions of the product may be vulnerable. Moreover, a user may be interested in specific types of vulnerabilities only such as buffer overflow or remote code execution. Neither keyword search nor embedding from the whole description facilitates these fine tuned retrievals.</p>
</div>
<div class="ltx_para ltx_noindent" id="S3.SS2.p3">
<p class="ltx_p" id="S3.SS2.p3.1"><span class="ltx_text ltx_font_bold" id="S3.SS2.p3.1.1">Developing the Retriever</span>
We propose a retriever model which is able to facilitate the above mentioned fine tune selection parameters. One key challenge is obtaining product name, problem type, platform and version properties for each CVE. CVE information available from the Mitre website is semi structured in json format. It has properties such as affected product/package name, problem type and version. However, values for these properties are often missing. No property is available for platform. Nevertheless all of these properties are usually included in the natural language text of CVE descriptions. Our proposed model utilizes these characteristics in an interesting and innovative way.</p>
</div>
<div class="ltx_para" id="S3.SS2.p4">
<p class="ltx_p" id="S3.SS2.p4.1">During the preprocessing phase, the LLM is used to extract the relevant properties from the description. Then the embedding for each property is created and stored in permanent storage. Finally these properties along with the storage location for corresponding embeddings are saved in multiple relational database files. Algorithm <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#algorithm1" title="In 3.2. Retriever ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">1</span></a> provides the pseudocode for this process. Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.F4" title="Figure 4 ‣ 3.2. Retriever ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">4</span></a> shows the steps taken during development of retriever model.</p>
</div>
<figure class="ltx_figure" id="S3.F4"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_square" height="249" id="S3.F4.g1" src="extracted/5784329/figures/Flowchart_Preprocessing.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4. </span>Retriever Development Phase</figcaption>
</figure>
<figure class="ltx_float ltx_algorithm" id="algorithm1">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing" id="algorithm1.2">
<div class="ltx_listingline" id="algorithm1.2.1">
<span class="ltx_tag ltx_tag_listingline">1</span>
</div>
<div class="ltx_listingline" id="algorithm1.2.2">
<span class="ltx_text ltx_font_bold" id="algorithm1.2.2.1">Input :</span> Path to CVE Json File P
</div>
<div class="ltx_listingline" id="algorithm1.2.3">
<span class="ltx_tag ltx_tag_listingline">2</span>
Initialize LLM Client LC
</div>
<div class="ltx_listingline" id="algorithm1.2.4">
<span class="ltx_tag ltx_tag_listingline">3</span>
Initialize Embedding Model EM
</div>
<div class="ltx_listingline" id="algorithm1.2.5">
<span class="ltx_tag ltx_tag_listingline">4</span>
Initialize Database Client D
</div>
<div class="ltx_listingline" id="algorithm1.2.6">
<span class="ltx_tag ltx_tag_listingline">5</span>
cve_json = Read File (P)
</div>
<div class="ltx_listingline" id="algorithm1.2.7">
<span class="ltx_tag ltx_tag_listingline">6</span>
state = cve_json[“cveMetadata”][“state”]
</div>
<div class="ltx_listingline" id="algorithm1.2.8">
<span class="ltx_tag ltx_tag_listingline">7</span>
<span class="ltx_text ltx_font_bold" id="algorithm1.2.8.1">if</span> <em class="ltx_emph ltx_font_italic" id="algorithm1.2.8.2">state == ‘rejected’</em> <span class="ltx_text ltx_font_bold" id="algorithm1.2.8.3">then</span>
</div>
<div class="ltx_listingline" id="algorithm1.2.9">
<span class="ltx_tag ltx_tag_listingline">8</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   return
</div>
<div class="ltx_listingline" id="algorithm1.2.10">
<span class="ltx_tag ltx_tag_listingline">9</span><span class="ltx_text ltx_font_bold" id="algorithm1.2.10.1">else</span>
</div>
<div class="ltx_listingline" id="algorithm1.2.11">
<span class="ltx_tag ltx_tag_listingline">10</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
cve_id = cve_json[“cveMetadata”][“cveId”]
</div>
<div class="ltx_listingline" id="algorithm1.2.12">
<span class="ltx_tag ltx_tag_listingline">11</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
info = cve_json[“containers”][“cna”]
</div>
<div class="ltx_listingline" id="algorithm1.2.13">
<span class="ltx_tag ltx_tag_listingline">12</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
description = info[“descriptions”][0][“value”]
</div>
<div class="ltx_listingline" id="algorithm1.2.14">  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_typewriter" id="algorithm1.2.14.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm1.2.14.2">Table name followed by values to be inserted in that table </span>
</div>
<div class="ltx_listingline" id="algorithm1.2.15">
<span class="ltx_tag ltx_tag_listingline">13</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
D.store(CVE_INFO, cve_id, description)
</div>
<div class="ltx_listingline" id="algorithm1.2.16">
<span class="ltx_tag ltx_tag_listingline">14</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm1.2.17">
<span class="ltx_tag ltx_tag_listingline">15</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   prompt = “provide the affected product name, platform and version if present using a key called ProductInfo, platform using a key called Platform, the problem type using a key called ProblemType in a single json from vulnerability information given below. ProductInfo should have properties ProductName and Version. Version should have properties VersionNumber and Qualifier whose
value would be ¡=, ¿=, == etc. ” + description 
</div>
<div class="ltx_listingline" id="algorithm1.2.18">
<span class="ltx_tag ltx_tag_listingline">16</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
result = LC.call(prompt)
</div>
<div class="ltx_listingline" id="algorithm1.2.19">
<span class="ltx_tag ltx_tag_listingline">17</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm1.2.20">
<span class="ltx_tag ltx_tag_listingline">18</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   product_name = result[ProductName]
</div>
<div class="ltx_listingline" id="algorithm1.2.21">
<span class="ltx_tag ltx_tag_listingline">19</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
product_name_vector = EM.process(product_name)
</div>
<div class="ltx_listingline" id="algorithm1.2.22">
<span class="ltx_tag ltx_tag_listingline">20</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
product_name_vector_file = cve_id + “_product.pt”
</div>
<div class="ltx_listingline" id="algorithm1.2.23">  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_typewriter" id="algorithm1.2.23.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm1.2.23.2">Saves the vector in the storage location specified by vector file </span>
</div>
<div class="ltx_listingline" id="algorithm1.2.24">
<span class="ltx_tag ltx_tag_listingline">21</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
save(product_name_vector, product_name_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.25">
<span class="ltx_tag ltx_tag_listingline">22</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
product_id = D.store(PRODUCT_INFO, cve_id, product_name, product_name_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.26">
<span class="ltx_tag ltx_tag_listingline">23</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
version = result[“ProductName”][“Version”]
</div>
<div class="ltx_listingline" id="algorithm1.2.27">
<span class="ltx_tag ltx_tag_listingline">24</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
version_number = version[“VersionNumber”]
</div>
<div class="ltx_listingline" id="algorithm1.2.28">
<span class="ltx_tag ltx_tag_listingline">25</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
qualifier = version[“Qualifier”]
</div>
<div class="ltx_listingline" id="algorithm1.2.29">
<span class="ltx_tag ltx_tag_listingline">26</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
D.store(VERSION_INFO, product_id, version_number, qualifier)
</div>
<div class="ltx_listingline" id="algorithm1.2.30">
<span class="ltx_tag ltx_tag_listingline">27</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm1.2.31">
<span class="ltx_tag ltx_tag_listingline">28</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   problem_type = result[ProblemType]
</div>
<div class="ltx_listingline" id="algorithm1.2.32">
<span class="ltx_tag ltx_tag_listingline">29</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
problem_type_vector = EM.process(problem_type)
</div>
<div class="ltx_listingline" id="algorithm1.2.33">
<span class="ltx_tag ltx_tag_listingline">30</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
problem_type_vector_file = cve_id + “_problem_type.pt”
</div>
<div class="ltx_listingline" id="algorithm1.2.34">
<span class="ltx_tag ltx_tag_listingline">31</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
save(problem_type_vector, problem_type_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.35">
<span class="ltx_tag ltx_tag_listingline">32</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
D.store(PROBLEM_TYPE, cve_id, problem_type, problem_type_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.36">
<span class="ltx_tag ltx_tag_listingline">33</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm1.2.37">
<span class="ltx_tag ltx_tag_listingline">34</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   platform = result[Platform]
</div>
<div class="ltx_listingline" id="algorithm1.2.38">
<span class="ltx_tag ltx_tag_listingline">35</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
platform_vector = EM.process(platform)
</div>
<div class="ltx_listingline" id="algorithm1.2.39">
<span class="ltx_tag ltx_tag_listingline">36</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
platform_vector_file = cve_id + “_platform.pt”
</div>
<div class="ltx_listingline" id="algorithm1.2.40">
<span class="ltx_tag ltx_tag_listingline">37</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
save(platform_vector, platform_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.41">
<span class="ltx_tag ltx_tag_listingline">38</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
D.store(PLATFORM, cve_id, platform, platform_vector_file)
</div>
<div class="ltx_listingline" id="algorithm1.2.42">
<span class="ltx_tag ltx_tag_listingline">39</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm1.2.43">
<span class="ltx_tag ltx_tag_listingline">40</span> end if
</div>
<div class="ltx_listingline" id="algorithm1.2.44">
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold" id="algorithm1.3.1.1">Algorithm 1</span> </span>Preprocess CVE (P)

</figcaption>
</figure>
<div class="ltx_para ltx_noindent" id="S3.SS2.p5">
<p class="ltx_p" id="S3.SS2.p5.1"><span class="ltx_text ltx_font_bold" id="S3.SS2.p5.1.1">Getting Context Using Retriever</span>
While calling LLM to create attack graphs from vulnerability information of a system, we use Retriever to build relevant context. Algorithm <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#algorithm2" title="In 3.2. Retriever ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">2</span></a> provides the pseudocode of this process.</p>
</div>
<div class="ltx_para" id="S3.SS2.p6">
<p class="ltx_p" id="S3.SS2.p6.1">User provides the Product/Package names which make up the target system in a query to the Retriever. Retriever obtains embeddings for each name in the query from Pre-Processor. All product names and corresponding embedding locations are fetched from the database. Embedding of each product name is loaded in memory from permanent storage, and cosine similarity between this product name embedding and query name embedding is calculated. If the calculated similarity is greater than the defined threshold, corresponding CVE is considered relevant and its description in included in the context. While adding new CVE description to the context, the number of token in the context is calculated to check if the context is within the number of tokens allowed by LLM. The same steps are repeated for Platform information too. Our prototype Retriever model uses only product name and platform properties for retrieval. However, it can be easily extended for problem type and version properties as well.</p>
</div>
<div class="ltx_para" id="S3.SS2.p7">
<p class="ltx_p" id="S3.SS2.p7.1">Our proposed Retriever is uniquely qualified to take advantage of semi structured nature of CVE information. It uses relational database to handle structured part i.e. fixed number of properties while using cosine similarity to handle natural language part i.e. using semantic similarity to match values for a particular property.</p>
</div>
<figure class="ltx_float ltx_algorithm" id="algorithm2">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing" id="algorithm2.2">
<div class="ltx_listingline" id="algorithm2.2.1">
<span class="ltx_tag ltx_tag_listingline">1</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.2">
<span class="ltx_text ltx_font_bold" id="algorithm2.2.2.1">Input :</span> User Query Q
</div>
<div class="ltx_listingline" id="algorithm2.2.3"> <span class="ltx_text ltx_font_bold" id="algorithm2.2.3.1">Output :</span> Context C which includes CVEs related to Q
</div>
<div class="ltx_listingline" id="algorithm2.2.4">
<span class="ltx_tag ltx_tag_listingline">2</span>
Initialize Embedding Model EM
</div>
<div class="ltx_listingline" id="algorithm2.2.5">
<span class="ltx_tag ltx_tag_listingline">3</span>
Initialize Database Client D
</div>
<div class="ltx_listingline" id="algorithm2.2.6">
<span class="ltx_tag ltx_tag_listingline">4</span>
query_vector = EM.process(Q)
</div>
<div class="ltx_listingline" id="algorithm2.2.7">
<span class="ltx_text ltx_font_typewriter" id="algorithm2.2.7.1">/* </span><span class="ltx_text ltx_font_typewriter" id="algorithm2.2.7.2">minimum cosine similarity value allowed between query_vector and a product_vector or platform_vector  */</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.8">
<span class="ltx_tag ltx_tag_listingline">5</span>
min_similarity = 0.68 
</div>
<div class="ltx_listingline" id="algorithm2.2.9">
<span class="ltx_text ltx_font_typewriter" id="algorithm2.2.9.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm2.2.9.2">maximum number of tokens allowed in the context, can be configured </span>
</div>
<div class="ltx_listingline" id="algorithm2.2.10">
<span class="ltx_tag ltx_tag_listingline">6</span>
context_tokens_per_query = 3750
</div>
<div class="ltx_listingline" id="algorithm2.2.11">
<span class="ltx_tag ltx_tag_listingline">7</span>
C = “”
</div>
<div class="ltx_listingline" id="algorithm2.2.12">
<span class="ltx_tag ltx_tag_listingline">8</span>
relevant_cves = set()
</div>
<div class="ltx_listingline" id="algorithm2.2.13">
<span class="ltx_tag ltx_tag_listingline">9</span>
retrieved_products = D.query(PRODUCT_INFO) 
</div>
<div class="ltx_listingline" id="algorithm2.2.14">
<span class="ltx_tag ltx_tag_listingline">10</span>
<span class="ltx_text ltx_font_bold" id="algorithm2.2.14.1">for</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.14.2">product in retrieved_products</em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.14.3">do</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.15">
<span class="ltx_tag ltx_tag_listingline">11</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
product_name_vector_file = product[3]
</div>
<div class="ltx_listingline" id="algorithm2.2.16">
<span class="ltx_tag ltx_tag_listingline">12</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
cve_id = product[1]
</div>
<div class="ltx_listingline" id="algorithm2.2.17">
<span class="ltx_tag ltx_tag_listingline">13</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
product_name_vector = load(product_name_vector_file)
</div>
<div class="ltx_listingline" id="algorithm2.2.18">
<span class="ltx_tag ltx_tag_listingline">14</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
score = calculate_cosine_similarity(query_vector, product_name_vector)
</div>
<div class="ltx_listingline" id="algorithm2.2.19">
<span class="ltx_tag ltx_tag_listingline">15</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_bold" id="algorithm2.2.19.1">if</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.19.2">score ¿ min_similarity</em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.19.3">then</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.20">
<span class="ltx_tag ltx_tag_listingline">16</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
relevant_cves.add(cve_id)
</div>
<div class="ltx_listingline" id="algorithm2.2.21">
<span class="ltx_tag ltx_tag_listingline">17</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm2.2.22">
<span class="ltx_tag ltx_tag_listingline">18</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   <span class="ltx_text ltx_font_bold" id="algorithm2.2.22.1">else</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.23">  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_typewriter" id="algorithm2.2.23.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm2.2.23.2">do not include embedding in context due to low cosine similarity </span>
</div>
<div class="ltx_listingline" id="algorithm2.2.24">
<span class="ltx_tag ltx_tag_listingline">19</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
continue

</div>
<div class="ltx_listingline" id="algorithm2.2.25">
<span class="ltx_tag ltx_tag_listingline">20</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>    end if
</div>
<div class="ltx_listingline" id="algorithm2.2.26">
<span class="ltx_tag ltx_tag_listingline">21</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
</div>
<div class="ltx_listingline" id="algorithm2.2.27">
<span class="ltx_tag ltx_tag_listingline">22</span> end for
</div>
<div class="ltx_listingline" id="algorithm2.2.28">
<span class="ltx_tag ltx_tag_listingline">23</span>retrieved_platforms = D.query(PLATFORM) 
</div>
<div class="ltx_listingline" id="algorithm2.2.29">
<span class="ltx_tag ltx_tag_listingline">24</span>
<span class="ltx_text ltx_font_bold" id="algorithm2.2.29.1">for</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.29.2">platform in retrieved_platforms</em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.29.3">do</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.30">
<span class="ltx_tag ltx_tag_listingline">25</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
platform_vector_file = platform[3]
</div>
<div class="ltx_listingline" id="algorithm2.2.31">
<span class="ltx_tag ltx_tag_listingline">26</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
cve_id = platform[1]
</div>
<div class="ltx_listingline" id="algorithm2.2.32">
<span class="ltx_tag ltx_tag_listingline">27</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
platform_vector = load(platform_vector_file)
</div>
<div class="ltx_listingline" id="algorithm2.2.33">
<span class="ltx_tag ltx_tag_listingline">28</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
score = calculate_cosine_similarity(query_vector, platform_vector)
</div>
<div class="ltx_listingline" id="algorithm2.2.34">
<span class="ltx_tag ltx_tag_listingline">29</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_bold" id="algorithm2.2.34.1">if</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.34.2">score ¿ min_similarity</em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.34.3">then</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.35">
<span class="ltx_tag ltx_tag_listingline">30</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
relevant_cves.add(cve_id)
</div>
<div class="ltx_listingline" id="algorithm2.2.36">
<span class="ltx_tag ltx_tag_listingline">31</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm2.2.37">
<span class="ltx_tag ltx_tag_listingline">32</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   <span class="ltx_text ltx_font_bold" id="algorithm2.2.37.1">else</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.38">  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_typewriter" id="algorithm2.2.38.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm2.2.38.2">do not include embedding in context due to low cosine similarity </span>
</div>
<div class="ltx_listingline" id="algorithm2.2.39">
<span class="ltx_tag ltx_tag_listingline">33</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
continue

</div>
<div class="ltx_listingline" id="algorithm2.2.40">
<span class="ltx_tag ltx_tag_listingline">34</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>    end if
</div>
<div class="ltx_listingline" id="algorithm2.2.41">
<span class="ltx_tag ltx_tag_listingline">35</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
</div>
<div class="ltx_listingline" id="algorithm2.2.42">
<span class="ltx_tag ltx_tag_listingline">36</span> end for
</div>
<div class="ltx_listingline" id="algorithm2.2.43">
<span class="ltx_tag ltx_tag_listingline">37</span>retrieved_cves = D_query(CVE_INFO, relevant_cves)
</div>
<div class="ltx_listingline" id="algorithm2.2.44">
<span class="ltx_tag ltx_tag_listingline">38</span>
<span class="ltx_text ltx_font_bold" id="algorithm2.2.44.1">for</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.44.2">cve in retrieved_cves</em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.44.3">do</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.45">
<span class="ltx_tag ltx_tag_listingline">39</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
description = cve[1]
</div>
<div class="ltx_listingline" id="algorithm2.2.46">
<span class="ltx_tag ltx_tag_listingline">40</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
num_tokens = Calculate Num Token (C + “—” + description)
</div>
<div class="ltx_listingline" id="algorithm2.2.47">
<span class="ltx_tag ltx_tag_listingline">41</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
<span class="ltx_text ltx_font_bold" id="algorithm2.2.47.1">if</span> <em class="ltx_emph ltx_font_italic" id="algorithm2.2.47.2">num_tokens ¡ context_tokens_per_query </em> <span class="ltx_text ltx_font_bold" id="algorithm2.2.47.3">then</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.48">
<span class="ltx_tag ltx_tag_listingline">42</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
C = C+“—” + description

</div>
<div class="ltx_listingline" id="algorithm2.2.49">
<span class="ltx_tag ltx_tag_listingline">43</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   <span class="ltx_text ltx_font_bold" id="algorithm2.2.49.1">else</span>
</div>
<div class="ltx_listingline" id="algorithm2.2.50">  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
break <span class="ltx_text ltx_font_typewriter" id="algorithm2.2.50.1">// </span><span class="ltx_text ltx_font_typewriter" id="algorithm2.2.50.2">C reached maximum token limit allowed in prompt </span>
</div>
<div class="ltx_listingline" id="algorithm2.2.51">
<span class="ltx_tag ltx_tag_listingline">44</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>     <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   

</div>
<div class="ltx_listingline" id="algorithm2.2.52">
<span class="ltx_tag ltx_tag_listingline">45</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>    end if
</div>
<div class="ltx_listingline" id="algorithm2.2.53">
<span class="ltx_tag ltx_tag_listingline">46</span>  <span class="ltx_rule" style="width:1px;height:100%;background:black;display:inline-block;"> </span>   
</div>
<div class="ltx_listingline" id="algorithm2.2.54">
<span class="ltx_tag ltx_tag_listingline">47</span> end for
</div>
<div class="ltx_listingline" id="algorithm2.2.55">return C


</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold" id="algorithm2.3.1.1">Algorithm 2</span> </span>Get Context (Q)</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S3.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.3. </span>LLM Handler</h3>
<div class="ltx_para" id="S3.SS3.p1">
<p class="ltx_p" id="S3.SS3.p1.1">After obtaining relevant context from Retriever, LLM Handler builds the prompt to LLM by adding a common prefix to the context. This common prefix includes some instructions for LLM such as the format of the output and how context should be treated. Then LLM Handler calls the LLM and receives the answer from it. Algorithm <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#algorithm3" title="In 3.3. LLM Handler ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">3</span></a> provides the pseudocode for this process. Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S3.F5" title="Figure 5 ‣ 3.3. LLM Handler ‣ 3. Proposed System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">5</span></a> presents the whole picture of attack graph generation for a system.</p>
</div>
<figure class="ltx_figure" id="S3.F5"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="282" id="S3.F5.g1" src="extracted/5784329/figures/Flowchart_Generation.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5. </span>Attack Graph Generation Steps</figcaption>
</figure>
<figure class="ltx_float ltx_algorithm" id="algorithm3">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing" id="algorithm3.2">
<div class="ltx_listingline" id="algorithm3.2.1">
<span class="ltx_tag ltx_tag_listingline">1</span>
</div>
<div class="ltx_listingline" id="algorithm3.2.2">
<span class="ltx_text ltx_font_bold" id="algorithm3.2.2.1">Input :</span> User Query Q which includes product names
</div>
<div class="ltx_listingline" id="algorithm3.2.3"> <span class="ltx_text ltx_font_bold" id="algorithm3.2.3.1">Output :</span> Attack Graph G
</div>
<div class="ltx_listingline" id="algorithm3.2.4">
<span class="ltx_tag ltx_tag_listingline">2</span>
context = Get Context(Q)
</div>
<div class="ltx_listingline" id="algorithm3.2.5">
<span class="ltx_tag ltx_tag_listingline">3</span>
prompt_common = “Create an attack graph in json format using nodes and edges from the vulnerability information given below. Chain the vulnerabilities if applicable. Vulnerabilities can be chained if precondition of one vulnerability is similar to the post condition of another vulnerability. Vulnerability with matching postcondition should be ahead in the chain. ”
</div>
<div class="ltx_listingline" id="algorithm3.2.6">
<span class="ltx_tag ltx_tag_listingline">4</span>
prompt = prompt_common + context
</div>
<div class="ltx_listingline" id="algorithm3.2.7">
<span class="ltx_tag ltx_tag_listingline">5</span>
Initialize LLM Client LC
</div>
<div class="ltx_listingline" id="algorithm3.2.8">
<span class="ltx_tag ltx_tag_listingline">6</span>
answer = LC.call(prompt)
</div>
<div class="ltx_listingline" id="algorithm3.2.9">
<span class="ltx_tag ltx_tag_listingline">7</span>
G = process_graph(answer)
</div>
<div class="ltx_listingline" id="algorithm3.2.10">
<span class="ltx_tag ltx_tag_listingline">8</span>
graph_file_name = “graph-” + timestamp + “.json”
</div>
<div class="ltx_listingline" id="algorithm3.2.11">
<span class="ltx_tag ltx_tag_listingline">9</span>
save(G, graph_file_name)
</div>
<div class="ltx_listingline" id="algorithm3.2.12">
<span class="ltx_tag ltx_tag_listingline">10</span>
show(G)
</div>
<div class="ltx_listingline" id="algorithm3.2.13">
return G

</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold" id="algorithm3.3.1.1">Algorithm 3</span> </span>Generate Attack Graph (Q)

</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S3.SS4">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.4. </span>Post-Processor</h3>
<div class="ltx_para" id="S3.SS4.p1">
<p class="ltx_p" id="S3.SS4.p1.1">The answer from LLM is processed by Post-Processor. It extracts the attack graph from the answer, saves it in database and shows the graph to the user.</p>
</div>
</section>
</section>
<section class="ltx_section" id="S4">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4. </span>Implementation</h2>
<div class="ltx_para" id="S4.p1">
<p class="ltx_p" id="S4.p1.1"><math alttext="\sf{CrystalBall}" class="ltx_Math" display="inline" id="S4.p1.1.m1.1"><semantics id="S4.p1.1.m1.1a"><mi id="S4.p1.1.m1.1.1" xref="S4.p1.1.m1.1.1.cmml">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</mi><annotation-xml encoding="MathML-Content" id="S4.p1.1.m1.1b"><ci id="S4.p1.1.m1.1.1.cmml" xref="S4.p1.1.m1.1.1">𝖢𝗋𝗒𝗌𝗍𝖺𝗅𝖡𝖺𝗅𝗅</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p1.1.m1.1c">\sf{CrystalBall}</annotation><annotation encoding="application/x-llamapun" id="S4.p1.1.m1.1d">sansserif_CrystalBall</annotation></semantics></math>is implemented using Python.</p>
</div>
<div class="ltx_para ltx_noindent" id="S4.p2">
<p class="ltx_p" id="S4.p2.1"><span class="ltx_text ltx_font_bold" id="S4.p2.1.1">Pre-Processor</span>: Standard file I/O operations are used to read threat reports and CVE JSON files. Additionally, json package is used to process CVE JSON files. Pretrained facebook/contriever-msmarco model from Hugging Face<cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib10" title="">huggingface, </a>)</cite> is used to obtain embeddings.</p>
</div>
<div class="ltx_para ltx_noindent" id="S4.p3">
<p class="ltx_p" id="S4.p3.1"><span class="ltx_text ltx_font_bold" id="S4.p3.1.1">Database:</span> We use SQLite as the relational database and utilize sqlite3 package to communicate with it.</p>
</div>
<div class="ltx_para ltx_noindent" id="S4.p4">
<p class="ltx_p" id="S4.p4.1"><span class="ltx_text ltx_font_bold" id="S4.p4.1.1">Retriever</span>: Retriever uses <span class="ltx_text ltx_font_bold" id="S4.p4.1.2">torch</span> package to store embeddings in “.pt” vector files during the development phase and load embeddings into memory from “.pt” files during attack graph generation phase. Additionally,
sentence_transformers.util package is used to determine cosine similarity scores between embeddings.</p>
</div>
<div class="ltx_para ltx_noindent" id="S4.p5">
<p class="ltx_p" id="S4.p5.1"><span class="ltx_text ltx_font_bold" id="S4.p5.1.1">LLM Handler</span>: openai package is used for automatic communication with ChatGPT models. On the other hand, Gemini does not expose any API endpoint. As a result, we have to provide the prompt to Geimini manually.</p>
</div>
<div class="ltx_para ltx_noindent" id="S4.p6">
<p class="ltx_p" id="S4.p6.1"><span class="ltx_text ltx_font_bold" id="S4.p6.1.1">Post-Processor</span>: json package is used to process the response from LLM. networks package is used to show the graph graphically.</p>
</div>
</section>
<section class="ltx_section" id="S5">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5. </span>Results</h2>
<div class="ltx_para" id="S5.p1">
<p class="ltx_p" id="S5.p1.1">We define a system consisting of Oculus, Jetson TX1 and Raspberry Pi as the target of the attack graph generated from vulnerability information.
The system is assumed to be fully connected i.e. each component can communicate with all other components. We use this system to study the performance of LLM under different scenarios.</p>
</div>
<section class="ltx_subsection" id="S5.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1. </span>Effect of Context Information in Prompt</h3>
<div class="ltx_para" id="S5.SS1.p1">
<p class="ltx_p" id="S5.SS1.p1.1">At the beginning, we give the following prompt to ChatGPT which does not have any context information.</p>
</div>
<div class="ltx_para" id="S5.SS1.p2">
<p class="ltx_p" id="S5.SS1.p2.1"><span class="ltx_text ltx_font_italic" id="S5.SS1.p2.1.1">Create an attack graph in json format using only nodes and edges as keys for a system comprising of Raspberry Pi, Oculus Desktop, NVIDIA Jetson Nano. </span></p>
</div>
<div class="ltx_para" id="S5.SS1.p3">
<p class="ltx_p" id="S5.SS1.p3.1">The resulting attack graph is presented in Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F6" title="Figure 6 ‣ 5.1. Effect of Context Information in Prompt ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">6</span></a>. This graph is very abstract. Moreover, it does not have any chaining between cross-device vulnerabilities.</p>
</div>
<figure class="ltx_figure" id="S5.F6"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="169" id="S5.F6.g1" src="extracted/5784329/figures/WithoutContextDefinedSystem.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6. </span>Attack Graph generated by ChatGPT when no context is given in the prompt.</figcaption>
</figure>
<div class="ltx_para" id="S5.SS1.p4">
<p class="ltx_p" id="S5.SS1.p4.1">After that, we provide vulnerabilities related to the components of the defined system as context. The resulting graph is shown in Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F7" title="Figure 7 ‣ 5.1. Effect of Context Information in Prompt ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">7</span></a>. This graph</p>
</div>
<figure class="ltx_figure" id="S5.F7"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="145" id="S5.F7.g1" src="extracted/5784329/figures/Attack_Graph_Defined_System.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 7. </span>Attack Graph generated by ChatGPT when relevant context is given in the prompt.</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S5.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2. </span>Attack Graph from a Threat Report</h3>
<div class="ltx_para" id="S5.SS2.p1">
<p class="ltx_p" id="S5.SS2.p1.1">Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F8" title="Figure 8 ‣ 5.2. Attack Graph from a Threat Report ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">8</span></a> shows an attack graph generated from a portion of Solar Winds Incident Threat report by using GPT-4 model. This portion focuses on the evasion tactics that were used by the attackers.The prompt for this attack graph is available in Appendix <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A3.SS2" title="C.2. Evasion Techniques ‣ Appendix C Prompt for Attack Graph from SolarWinds Attack Threat Report ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">C.2</span></a>. On the other hand, Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.F2" title="Figure 2 ‣ 2.2. Attack Graph ‣ 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">2</span></a> shows the attack graph generated from the full threat report. Even though the GPT -4 model is able to process the full incident report, it creates a very high-level attack graph. In Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S2.F2" title="Figure 2 ‣ 2.2. Attack Graph ‣ 2. Background ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">2</span></a>, only the node <span class="ltx_text ltx_font_italic" id="S5.SS2.p1.1.1">Operational Security</span> and its children represent evasion techniques deployed by the attackers despite having access to the same information as when it produces Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F8" title="Figure 8 ‣ 5.2. Attack Graph from a Threat Report ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">8</span></a>. As a result we can conclude that GPT-4 performs better when dealing with smaller prompts.</p>
</div>
<figure class="ltx_figure" id="S5.F8"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="337" id="S5.F8.g1" src="extracted/5784329/figures/SolarwindsEvasionTechniques.png" width="598"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 8. </span>Attack Graph Created from a part of Solar Winds Threat report by GPT-4. This part of the report focuses on the evasion techniques adopted by the attackers</figcaption>
</figure>
</section>
<section class="ltx_subsection" id="S5.SS3">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.3. </span>Comparison among Different LLMs</h3>
<div class="ltx_para" id="S5.SS3.p1">
<p class="ltx_p" id="S5.SS3.p1.1">We evaluate the performances of three different LLM models in generating attack graphs from vulnerability information (CVEs) and from threat reports.</p>
</div>
<section class="ltx_subsubsection" id="S5.SS3.SSS1">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.3.1. </span>Attack Graph from Vulnerability Information</h4>
<div class="ltx_para" id="S5.SS3.SSS1.p1">
<p class="ltx_p" id="S5.SS3.SSS1.p1.1">Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F7" title="Figure 7 ‣ 5.1. Effect of Context Information in Prompt ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">7</span></a>, Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F9" title="Figure 9 ‣ 5.3.1. Attack Graph from Vulnerability Information ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">9</span></a> and Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F10" title="Figure 10 ‣ 5.3.1. Attack Graph from Vulnerability Information ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">10</span></a> show attack graphs generated by different LLM models for the system defined at the beginning of this section. Same prompt is sent to each model. The prompt is available in Appendix <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A1" title="Appendix A Prompt for Attack Graph of Defined System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">A</span></a> if interested.
From these graphs, we can conclude that the performance of the GPT-4 model is the best in terms of the details provided in the graph and cross-device vulnerability chaining.</p>
</div>
<div class="ltx_para" id="S5.SS3.SSS1.p2">
<p class="ltx_p" id="S5.SS3.SSS1.p2.1">Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F7" title="Figure 7 ‣ 5.1. Effect of Context Information in Prompt ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">7</span></a>, Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F9" title="Figure 9 ‣ 5.3.1. Attack Graph from Vulnerability Information ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">9</span></a> and Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F10" title="Figure 10 ‣ 5.3.1. Attack Graph from Vulnerability Information ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">10</span></a> show attack graphs created by different LLM models for the system described at the beginning of this section. The same prompt was sent to each model, and the prompt is available in Appendix <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A1" title="Appendix A Prompt for Attack Graph of Defined System ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">A</span></a> if interested. From these graphs, we can observe that the GPT-4 model performs the best in terms of the details provided in the graph and cross-device vulnerability chaining.</p>
</div>
<figure class="ltx_figure" id="S5.F9"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="156" id="S5.F9.g1" src="extracted/5784329/figures/defined_system_GPT_3.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 9. </span>Attack Graph of the defined system generated by GPT-3.5 model</figcaption>
</figure>
<figure class="ltx_figure" id="S5.F10"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="222" id="S5.F10.g1" src="extracted/5784329/figures/defined_system_BARD.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 10. </span>Attack Graph of the defined system generated by Bard model</figcaption>
</figure>
</section>
<section class="ltx_subsubsection" id="S5.SS3.SSS2">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.3.2. </span>Attack Graph from Threat Report</h4>
<div class="ltx_para" id="S5.SS3.SSS2.p1">
<p class="ltx_p" id="S5.SS3.SSS2.p1.1">We use a threat report about Kubernetes clusters being hacked for evaluation. The prompt is available in Appendix <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#A2" title="Appendix B Prompt for Attack Graph from Kubernetes Cluster Hacked Threat Report ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">B</span></a>. In Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F11" title="Figure 11 ‣ 5.3.2. Attack Graph from Threat Report ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">11</span></a>, Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F12" title="Figure 12 ‣ 5.3.2. Attack Graph from Threat Report ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">12</span></a>, and Figure <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#S5.F13" title="Figure 13 ‣ 5.3.2. Attack Graph from Threat Report ‣ 5.3. Comparison among Different LLMs ‣ 5. Results ‣ Using Retriever Augmented Large Language Models for Attack Graph Generation"><span class="ltx_text ltx_ref_tag">13</span></a>, attack graphs generated by different LLM models are presented. Among these, only the graph produced by the GPT-4 model is able to effectively represent the attack paths in a logically coherent manner. The threat report outlines two distinct attack paths, both of which are accurately captured by the GPT-4 model.</p>
</div>
<figure class="ltx_figure" id="S5.F11"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="174" id="S5.F11.g1" src="extracted/5784329/figures/Kubernets_gpt4.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 11. </span>Attack Graph from Kubernetes Cluster Hacked Threat Report generated by GPT-4 model</figcaption>
</figure>
<figure class="ltx_figure" id="S5.F12"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="178" id="S5.F12.g1" src="extracted/5784329/figures/kubernets_gpt3.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 12. </span>Attack Graph from Kubernetes Cluster Hacked Threat Report generated by GPT-3.5 model</figcaption>
</figure>
<figure class="ltx_figure" id="S5.F13"><img alt="Refer to caption" class="ltx_graphics ltx_centering ltx_img_landscape" height="123" id="S5.F13.g1" src="extracted/5784329/figures/kubernets_bard.png" width="299"/>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 13. </span>Attack Graph from Kubernetes Cluster Hacked Threat Report generated by BARD model</figcaption>
</figure>
</section>
</section>
<section class="ltx_subsection" id="S5.SS4">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.4. </span>Attempts on Expanding the Attack Graph Gradually</h3>
<div class="ltx_para" id="S5.SS4.p1">
<p class="ltx_p" id="S5.SS4.p1.1">All popular LLMs have token limits in both prompt and output. As a result, it is hard to get a complete attack graph for a complex system through a single call to LLM. Besides, LLM normally skips low level technical/implementation details and provides high level attack graphs. We explored different ways to address these problems. Our findings are provided below:</p>
<ul class="ltx_itemize" id="S5.I1">
<li class="ltx_item" id="S5.I1.i1" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S5.I1.i1.p1">
<p class="ltx_p" id="S5.I1.i1.p1.1">We broke down the entire context into smaller chunks based on the token limit of the LLM. Then, we sent multiple requests to the LLM, each with a single chunk as context. After receiving results from each call, we combined them to create the complete graph. To build the full graph, we merged all the nodes and edges from the partial graphs.</p>
</div>
</li>
<li class="ltx_item" id="S5.I1.i2" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S5.I1.i2.p1">
<p class="ltx_p" id="S5.I1.i2.p1.1">Sometimes, answers from LLMs are cut in the middle due to the token limit. We are able to fix the malformed json output and create a partial attack graph from the answer. We also tried to make a follow-up call to the LLM to get the full attack graph. We included the partial answer in the prompt along with the original context and asked LLM to provide the rest of the graph. However, this caused the prompt to exceed the maximum allowed token number.</p>
</div>
</li>
<li class="ltx_item" id="S5.I1.i3" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span>
<div class="ltx_para" id="S5.I1.i3.p1">
<p class="ltx_p" id="S5.I1.i3.p1.1">Attempting to zoom in the attack graph generated by LLM i.e. get more details about the steps depicted in the graph, we made follow up calls to LLM by including an edge from the graph and asking LLM to provide more detailed graph for that particular edge. However, LLM provided the same attack graph again instead of adding more details for the selected edge. Afterwards, we tried another approach where we asked LLM to provide the part of the context which is related to the selected edge. LLM was able to perform that task correctly.</p>
</div>
</li>
</ul>
</div>
</section>
</section>
<section class="ltx_section" id="S6">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6. </span>Related Work</h2>
<div class="ltx_para" id="S6.p1">
<p class="ltx_p" id="S6.p1.1">Existing works on Attack Graph Generation can be divided into two main approaches.</p>
</div>
<div class="ltx_para" id="S6.p2">
<p class="ltx_p" id="S6.p2.1">One approach <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib11" title="">jha2002two, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib12" title="">noel2002combinatorial, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib13" title="">ou2005mulval, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib1" title="">al2019a2g2v, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib2" title="">sheyner2002automated, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib3" title="">ou2006scalable, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib14" title="">hankin2022attack, </a>)</cite> uses model reasoning/combinatorial analysis to create attack graphs. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib13" title="">ou2005mulval, </a>)</cite> presents MulVAL, an end-to-end framework and reasoning system for vulnerability analysis on a network. MulVAL uses Datalog as the modeling language. The information in the vulnerability database are encoded as Datalog facts. The reasoning engine consists of a collection of Datalog rules. These rules describe the behavior of the operating system and how the different components in the network interact with each other. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib1" title="">al2019a2g2v, </a>)</cite> proposes
a model-checking-based automated attack graph generator
and visualizer called A2G2V. A2G2V tool uses system architecture and atomic attack behaviors captured in AADL and AGREE Annex as input. The AADL+AGREE model is translated into its Lustre
equivalent, and further analyzed by using the model-checker
JKind. A2G2V tool uses JKind model-checker to generate attack sequences by iteratively relaxing specifications whereas Graphviz tool is integrated for attack graph visualization. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib12" title="">noel2002combinatorial, </a>)</cite> establishes encoding rules to reason about interdependent vulnerabilities and exploits. The combinatorial analysis of network vulnerability models attacker exploits in terms of exploit pre- and post-conditions to capture the interdependencies of the exploits. Inference engines then reason about combinations of exploits with the goal of discovering attack paths for the assumed attacker goals. Model reasoning and combinatorial analysis based approaches are highly accurate and provide a deep understanding of potential attack paths. However, they are computationally intensive and do not scale well with large, complex networks. Moreover, these works require manual input of related vulnerability information for a target system.</p>
</div>
<div class="ltx_para" id="S6.p3">
<p class="ltx_p" id="S6.p3.1">Another approach <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib4" title="">payne2019secure, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib5" title="">bezawada2019agbuilder, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib15" title="">jin2023prometheus, </a>; <a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib6" title="">husari2017ttpdrill, </a>)</cite> for automatic attack graph generation involves using natural language processing (NLP) techniques and machine learning models. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib4" title="">payne2019secure, </a>)</cite> introduces the concept of attack circuits, which are created using input/output pairs derived from CVEs with the aid of NLP, and an attack graph that is composed of these circuits. To construct the attack circuits, vulnerability descriptions from a vulnerability database are used. For each item in the database, an input/output pair is generated, where the input represents the attack source and the output represents the attack target. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib5" title="">bezawada2019agbuilder, </a>)</cite> models the attack graph generation and analysis problem as a planning problem. For that purpose, the attack graph is encoded in the Planner Domain Definition Language (PDDL) representation, referred to as a PDDL domain. The corresponding tool, AGBuilder –Attack Graph Builder, is designed to automatically generate PDDL based representation of attacks from textual description of vulnerabilities found in the CVE system or the NVD system. <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib6" title="">husari2017ttpdrill, </a>)</cite> develops a tool called TTPDrill which performs automated and context-aware analysis of cyber threat intelligence (CTI) and learns attack patterns (TTPs) from commonly available CTI sources. TTPDrill uses a novel text mining approach extracts threat actions based on semantic relationship. In addition, <cite class="ltx_cite ltx_citemacro_citep">(<a class="ltx_ref" href="https://arxiv.org/html/2408.05855v1#bib.bib6" title="">husari2017ttpdrill, </a>)</cite> presents a novel threat-action ontology that is sufficiently rich to understand the specifications and context of malicious actions. The NLP and machine learning based approach can efficiently process large volumes of data and adapt to new threats. However, training these machine learning models require significant amount of quality training data, time and computational resources.</p>
</div>
</section>
<section class="ltx_section" id="S7">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">7. </span>Conclusion</h2>
<div class="ltx_para" id="S7.p1">
<p class="ltx_p" id="S7.p1.1">In this paper, we have delved into the novel application of large language models like ChatGPT for the task of generating attack graphs. Our focus has been on the automatic chaining of Common Vulnerabilities and Exposures (CVEs) based on their preconditions and postconditions as well as generating attack graphs from threat reports. The findings suggest that ChatGPT not only effectively generates but also enhances the quality of attack graphs by introducing greater contextual relevance and nuanced understanding.</p>
</div>
<div class="ltx_para" id="S7.p2">
<p class="ltx_p" id="S7.p2.1">However, it is important to note the limitations of this approach. While the language model performs well in many cases, the lack of domain-specific expertise can sometimes result in graphs that may need further refinement or validation. Moreover, the ethical implications of using machine learning models for cybersecurity tasks, including the potential for misuse, require thorough scrutiny.</p>
</div>
<div class="ltx_para" id="S7.p3">
<p class="ltx_p" id="S7.p3.1">In summary, the application of large language models like ChatGPT in the cybersecurity domain, specifically for generating attack graphs, reveals promising results that merit deeper investigation and broader application. The potential benefits in terms of efficiency, accuracy, and real-time relevance make it a compelling approach for modern-day security challenges.</p>
</div>
</section>
<section class="ltx_bibliography" id="bib">
<h2 class="ltx_title ltx_title_bibliography">References</h2>
<ul class="ltx_biblist">
<li class="ltx_bibitem" id="bib.bib1">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
Alaa T Al Ghazo, Mariam Ibrahim, Hao Ren, and Ratnesh Kumar.

</span>
<span class="ltx_bibblock">A2g2v: Automatic attack graph generation and visualization and its
applications to computer and scada networks.

</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_font_italic" id="bib.bib1.1.1">IEEE Transactions on Systems, Man, and Cybernetics: Systems</span>,
50(10):3488–3498, 2019.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib2">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
Oleg Sheyner, Joshua Haines, Somesh Jha, Richard Lippmann, and Jeannette M
Wing.

</span>
<span class="ltx_bibblock">Automated generation and analysis of attack graphs.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib2.1.1">Proceedings 2002 IEEE Symposium on Security and Privacy</span>,
pages 273–284. IEEE, 2002.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib3">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
Xinming Ou, Wayne F Boyer, and Miles A McQueen.

</span>
<span class="ltx_bibblock">A scalable approach to attack graph generation.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib3.1.1">Proceedings of the 13th ACM conference on Computer and
communications security</span>, pages 336–345, 2006.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib4">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
Josh Payne, Karan Budhraja, and Ashish Kundu.

</span>
<span class="ltx_bibblock">How secure is your iot network?

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib4.1.1">2019 IEEE International Congress on Internet of Things
(ICIOT)</span>, pages 181–188. IEEE, 2019.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib5">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
Bruhadeshwar Bezawada, Indrajit Ray, and Kushagra Tiwary.

</span>
<span class="ltx_bibblock">Agbuilder: an ai tool for automated attack graph building, analysis,
and refinement.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib5.1.1">Data and Applications Security and Privacy XXXIII: 33rd
Annual IFIP WG 11.3 Conference, DBSec 2019, Charleston, SC, USA, July 15–17,
2019, Proceedings 33</span>, pages 23–42. Springer, 2019.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib6">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
Ghaith Husari, Ehab Al-Shaer, Mohiuddin Ahmed, Bill Chu, and Xi Niu.

</span>
<span class="ltx_bibblock">Ttpdrill: Automatic and accurate extraction of threat actions from
unstructured text of cti sources.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib6.1.1">Proceedings of the 33rd annual computer security applications
conference</span>, pages 103–115, 2017.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib7">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
Cve.

</span>
<span class="ltx_bibblock"><a class="ltx_ref ltx_url ltx_font_typewriter" href="https://cve.mitre.org/" title="">https://cve.mitre.org/</a>.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib8">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
The mitre corporation.

</span>
<span class="ltx_bibblock"><a class="ltx_ref ltx_url ltx_font_typewriter" href="https://www.mitre.org/" title="">https://www.mitre.org/</a>.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib9">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
Cve database.

</span>
<span class="ltx_bibblock"><a class="ltx_ref ltx_url ltx_font_typewriter" href="https://github.com/CVEProject/cvelistV5" title="">https://github.com/CVEProject/cvelistV5</a>.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib10">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
Hugging face.

</span>
<span class="ltx_bibblock"><a class="ltx_ref ltx_url ltx_font_typewriter" href="https://huggingface.co/" title="">https://huggingface.co/</a>.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib11">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
Somesh Jha, Oleg Sheyner, and Jeannette Wing.

</span>
<span class="ltx_bibblock">Two formal analyses of attack graphs.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib11.1.1">Proceedings 15th IEEE Computer Security Foundations Workshop.
CSFW-15</span>, pages 49–63. IEEE, 2002.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib12">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
Steven E Noel, Brian O’Berry, Charles Hutchinson, Sushil Jajodia, Lynn M
Keuthan, and Andy Nguyen.

</span>
<span class="ltx_bibblock">Combinatorial analysis of network security.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib12.1.1">Wavelet and Independent Component Analysis Applications IX</span>,
volume 4738, pages 140–149. SPIE, 2002.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib13">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[13]</span>
<span class="ltx_bibblock">
Xinming Ou, Sudhakar Govindavajhala, Andrew W Appel, et al.

</span>
<span class="ltx_bibblock">Mulval: A logic-based network security analyzer.

</span>
<span class="ltx_bibblock">In <span class="ltx_text ltx_font_italic" id="bib.bib13.1.1">USENIX security symposium</span>, volume 8, pages 113–128.
Baltimore, MD, 2005.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib14">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[14]</span>
<span class="ltx_bibblock">
Chris Hankin, Pasquale Malacaria, et al.

</span>
<span class="ltx_bibblock">Attack dynamics: an automatic attack graph generation framework based
on system topology, capec, cwe, and cve databases.

</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_font_italic" id="bib.bib14.1.1">Computers &amp; Security</span>, 123:102938, 2022.

</span>
</li>
<li class="ltx_bibitem" id="bib.bib15">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">[15]</span>
<span class="ltx_bibblock">
Xin Jin, Charalampos Katsis, Fan Sang, Jiahao Sun, Elisa Bertino, Ramana Rao
Kompella, and Ashish Kundu.

</span>
<span class="ltx_bibblock">Prometheus: Infrastructure security posture analysis with
ai-generated attack graphs.

</span>
<span class="ltx_bibblock"><span class="ltx_text ltx_font_italic" id="bib.bib15.1.1">arXiv preprint arXiv:2312.13119</span>, 2023.

</span>
</li>
</ul>
</section>
<section class="ltx_appendix" id="A1">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix A </span>Prompt for Attack Graph of Defined System</h2>
<div class="ltx_para" id="A1.p1">
<p class="ltx_p" id="A1.p1.1">Create an attack graph in json format using only nodes and edges as keys from the vulnerability information given below. node should have id, label, precondition and postcondition as properties. edge should have from, to and label properties. Do not give a simplified graph. Add as much detail as possible. Incorporate all possible information in nodes and edges. Do not create separate keys for them in the json. Chain the vulnerabilities if applicable. Vulnerabilities can be chained if precondition of one vulnerability is similar to the post condition of another vulnerability. Vulnerability with matching postcondition should be ahead in the chain. Return only the json as response. Do not put any text before or after the json.</p>
</div>
<div class="ltx_para" id="A1.p2">
<p class="ltx_p" id="A1.p2.1">The web application component of piSignage before 2.6.4 allows a remote attacker (authenticated as a low-privilege user) to download arbitrary files from the Raspberry Pi via api/settings/log?file=../ path traversal. In other words, this issue is in the player API for log download.</p>
</div>
<div class="ltx_para" id="A1.p3">
<p class="ltx_p" id="A1.p3.1">A remote web page could inject arbitrary HTML code into the Oculus Browser UI, allowing an attacker to spoof UI and potentially execute code. This affects the Oculus Browser starting from version 5.2.7 until 5.7.11.</p>
</div>
<div class="ltx_para" id="A1.p4">
<p class="ltx_p" id="A1.p4.1">Writing to an unprivileged file from a privileged OVRRedir.exe process in Oculus Desktop before 1.44.0.32849 on Windows allows local users to write to arbitrary files and consequently gain privileges via vectors involving a hard link to a log file.</p>
</div>
<div class="ltx_para" id="A1.p5">
<p class="ltx_p" id="A1.p5.1">An issue was discovered in includes/webconsole.php in RaspAP 2.5. With authenticated access, an attacker can use a misconfigured (and virtually unrestricted) web console to attack the underlying OS (Raspberry Pi) running this software, and execute commands on the system (including ones for uploading of files and execution of code).</p>
</div>
<div class="ltx_para" id="A1.p6">
<p class="ltx_p" id="A1.p6.1">Due to a bug with management of handles in OVRServiceLauncher.exe, an attacker could expose a privileged process handle to an unprivileged process, leading to local privilege escalation. This issue affects Oculus Desktop versions after 1.39 and prior to 31.1.0.67.507.</p>
</div>
<div class="ltx_para" id="A1.p7">
<p class="ltx_p" id="A1.p7.1">Raspberry Pi 3 B+ and 4 B devices through 2021-08-09, in certain specific use cases in which the device supplies power to audio-output equipment, allow remote attackers to recover speech signals from an LED on the device, via a telescope and an electro-optical sensor, aka a ”Glowworm” attack. We assume that the Raspberry Pi supplies power to some speakers. The power indicator LED of the Raspberry Pi is connected directly to the power line, as a result, the intensity of a deviceś power indicator LED is correlative to the power consumption. The sound played by the speakers affects the Raspberry Piś power consumption and as a result is also correlative to the light intensity of the LED. By analyzing measurements obtained from an electro-optical sensor directed at the power indicator LED of the Raspberry Pi, we can recover the sound played by the speakers.</p>
</div>
<div class="ltx_para" id="A1.p8">
<p class="ltx_p" id="A1.p8.1">Raspberry Pi OS through 5.10 has the raspberry default password for the pi account. If not changed, attackers can gain administrator privileges.</p>
</div>
<div class="ltx_para" id="A1.p9">
<p class="ltx_p" id="A1.p9.1">NVIDIA distributions of Jetson Linux contain a vulnerability where an error in the IOMMU configuration may allow an unprivileged attacker with physical access to the board direct read/write access to the entire system address space through the PCI bus. Such an attack could result in denial of service, code execution, escalation of privileges, and impact to data integrity and confidentiality. The scope impact may extend to other components.</p>
</div>
</section>
<section class="ltx_appendix" id="A2">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix B </span>Prompt for Attack Graph from Kubernetes Cluster Hacked Threat Report</h2>
<div class="ltx_para" id="A2.p1">
<p class="ltx_p" id="A2.p1.1">Create an attack graph in json format using nodes and edges from following attack scenario: The security researchers at Microsoft analyzed the attack and identified two attack paths were used. The first attack path is establishing and enumerating the PostgreSQL servers that had configuration issues. From there one of the most common misconfigurations that were being exploited is the “trust authentication” setting which allows PostgreSQL to make an assumption that any connection that is established towards the server is authorized to get database access. In addition, if a security issue exists such that a broad range of IP addresses are being assigned then any IP address that the attacker may be using can be used to gain access to the server. The second attack path is trying to exploit a security flaw in container images. In this particular scenario, the attackers are searching for a remote code execution vulnerability which will then allow them to push their payload and gain access to the server in that manner. From what has been seen so far, the attackers are trying to find and exploit security flaws in these applications: WordPress Liferay PHPUnit Oracle WebLogic.</p>
</div>
</section>
<section class="ltx_appendix" id="A3">
<h2 class="ltx_title ltx_title_appendix">
<span class="ltx_tag ltx_tag_appendix">Appendix C </span>Prompt for Attack Graph from SolarWinds Attack Threat Report</h2>
<section class="ltx_subsection" id="A3.SS1">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">C.1. </span>Full Report</h3>
<div class="ltx_para" id="A3.SS1.p1">
<p class="ltx_p" id="A3.SS1.p1.1">Create an attack graph in json format using only nodes and edges as keys from the attack scenario given below. node should have id, label, edge should have from, to and label properties. Do not give a simplified graph. Add as much detail as possible. Incorporate all possible information in nodes and edges. Do not create separate keys for them in the json. Give only the graph in json format. Do not put text before or after json.</p>
</div>
<div class="ltx_para" id="A3.SS1.p2">
<p class="ltx_p" id="A3.SS1.p2.1">Executive Summary
We have discovered a global intrusion campaign. We are tracking the actors behind this campaign as UNC2452.
FireEye discovered a supply chain attack trojanizing SolarWinds Orion business software updates in order to distribute malware we call SUNBURST.
The attacker’s post compromise activity leverages multiple techniques to evade detection and obscure their activity, but these efforts also offer some opportunities for detection.
The campaign is widespread, affecting public and private organizations around the world.
FireEye is releasing signatures to detect this threat actor and supply chain attack in the wild. These are found on our public GitHub page. FireEye products and services can help customers detect and block this attack.
Summary
FireEye has uncovered a widespread campaign, that we are tracking as UNC2452. The actors behind this campaign gained access to numerous public and private organizations around the world. They gained access to victims via trojanized updates to SolarWind’s Orion IT monitoring and management software. This campaign may have begun as early as Spring 2020 and is currently ongoing. Post compromise activity following this supply chain compromise has included lateral movement and data theft. The campaign is the work of a highly skilled actor and the operation was conducted with significant operational security.</p>
</div>
<div class="ltx_para" id="A3.SS1.p3">
<p class="ltx_p" id="A3.SS1.p3.1">SUNBURST Backdoor
SolarWinds.Orion.Core.BusinessLayer.dll is a SolarWinds digitally-signed component of the Orion software framework that contains a backdoor that communicates via HTTP to third party servers. We are tracking the trojanized version of this SolarWinds Orion plug-in as SUNBURST.</p>
</div>
<div class="ltx_para" id="A3.SS1.p4">
<p class="ltx_p" id="A3.SS1.p4.1">After an initial dormant period of up to two weeks, it retrieves and executes commands, called “Jobs”, that include the ability to transfer files, execute files, profile the system, reboot the machine, and disable system services. The malware masquerades its network traffic as the Orion Improvement Program (OIP) protocol and stores reconnaissance results within legitimate plugin configuration files allowing it to blend in with legitimate SolarWinds activity. The backdoor uses multiple obfuscated blocklists to identify forensic and anti-virus tools running as processes, services, and drivers.
Multiple trojanzied updates were digitally signed from March - May 2020 and posted to the SolarWinds updates website, including:</p>
</div>
<div class="ltx_para" id="A3.SS1.p5">
<p class="ltx_p" id="A3.SS1.p5.1">hxxps://downloads.solarwinds[.]com/solarwinds/CatalogResources/
Core/2019.4/2019.4.5220.20574/SolarWinds-Core-v2019.4.5220-Hotfix5.msp
The trojanized update file is a standard Windows Installer Patch file that includes compressed resources associated with the update, including the trojanized SolarWinds.Orion.Core.BusinessLayer.dll component. Once the update is installed, the malicious DLL will be loaded by the legitimate SolarWinds.BusinessLayerHost.exe or SolarWinds.BusinessLayerHostx64.exe (depending on system configuration). After a dormant period of up to two weeks, the malware will attempt to resolve a subdomain of avsvmcloud[.]com. The DNS response will return a CNAME record that points to a Command and Control (C2) domain. The C2 traffic to the malicious domains is designed to mimic normal SolarWinds API communications. The list of known malicious infrastructure is available on FireEye’s GitHub page.</p>
</div>
<div class="ltx_para" id="A3.SS1.p6">
<p class="ltx_p" id="A3.SS1.p6.1">Worldwide Victims Across Multiple Verticals
FireEye has detected this activity at multiple entities worldwide. The victims have included government, consulting, technology, telecom and extractive entities in North America, Europe, Asia and the Middle East. We anticipate there are additional victims in other countries and verticals. FireEye has notified all entities we are aware of being affected.</p>
</div>
<div class="ltx_para" id="A3.SS1.p7">
<p class="ltx_p" id="A3.SS1.p7.1">Post Compromise Activity and Detection Opportunities
We are currently tracking the software supply chain compromise and related post intrusion activity as UNC2452. After gaining initial access, this group uses a variety of techniques to disguise their operations while they move laterally (Figure 2). This actor prefers to maintain a light malware footprint, instead preferring legitimate credentials and remote access for access into a victim’s environment.</p>
</div>
<div class="ltx_para" id="A3.SS1.p8">
<p class="ltx_p" id="A3.SS1.p8.1">This section will detail the notable techniques and outline potential opportunities for detection.</p>
</div>
<div class="ltx_para" id="A3.SS1.p9">
<p class="ltx_p" id="A3.SS1.p9.1">TEARDROP and BEACON Malware Used</p>
</div>
<div class="ltx_para" id="A3.SS1.p10">
<p class="ltx_p" id="A3.SS1.p10.1">Multiple SUNBURST samples have been recovered, delivering different payloads. In at least one instance the attackers deployed a previously unseen memory-only dropper we’ve dubbed TEARDROP to deploy Cobalt Strike BEACON.</p>
</div>
<div class="ltx_para" id="A3.SS1.p11">
<p class="ltx_p" id="A3.SS1.p11.1">TEARDROP is a memory only dropper that runs as a service, spawns a thread and reads from the file “gracious_truth.jpg”, which likely has a fake JPG header. Next it checks that HKU
<br class="ltx_break"/>SOFTWARE
<br class="ltx_break"/>Microsoft
<br class="ltx_break"/>CTF exists, decodes an embedded payload using a custom rolling XOR algorithm and manually loads into memory an embedded payload using a custom PE-like file format. TEARDROP does not have code overlap with any previously seen malware. We believe that this was used to execute a customized Cobalt Strike BEACON.</p>
</div>
<div class="ltx_para" id="A3.SS1.p12">
<p class="ltx_p" id="A3.SS1.p12.1">Mitigation: FireEye has provided two Yara rules to detect TEARDROP available on our GitHub. Defenders should look for the following alerts from FireEye HX: MalwareGuard and WindowsDefender:</p>
</div>
<div class="ltx_para" id="A3.SS1.p13">
<p class="ltx_p" id="A3.SS1.p13.1">Process Information</p>
</div>
<div class="ltx_para" id="A3.SS1.p14">
<p class="ltx_p" id="A3.SS1.p14.1">file_operation_closed
file-path*: “c:
<br class="ltx_break"/>windows
<br class="ltx_break"/>syswow64
<br class="ltx_break"/>netsetupsvc.dll
actor-process:
pid: 17900</p>
</div>
<div class="ltx_para" id="A3.SS1.p15">
<p class="ltx_p" id="A3.SS1.p15.1">Window’s defender Exploit Guard log entries: (Microsoft-Windows-Security-Mitigations/KernelMode event ID 12)</p>
</div>
<div class="ltx_para" id="A3.SS1.p16">
<p class="ltx_p" id="A3.SS1.p16.1">Process”
<br class="ltx_break"/>Device
<br class="ltx_break"/>HarddiskVolume2
<br class="ltx_break"/>Windows
<br class="ltx_break"/>System32
<br class="ltx_break"/>svchost.exe” (PID XXXXX) would have been blocked from loading the non-Microsoft-signed binary
‘
<br class="ltx_break"/>Windows
<br class="ltx_break"/>SysWOW64
<br class="ltx_break"/>NetSetupSvc.dll’</p>
</div>
<div class="ltx_para" id="A3.SS1.p17">
<p class="ltx_p" id="A3.SS1.p17.1">Attacker Hostnames Match Victim Environment</p>
</div>
<div class="ltx_para" id="A3.SS1.p18">
<p class="ltx_p" id="A3.SS1.p18.1">The actor sets the hostnames on their command and control infrastructure to match a legitimate hostname found within the victim’s environment. This allows the adversary to blend into the environment, avoid suspicion, and evade detection.</p>
</div>
<div class="ltx_para" id="A3.SS1.p19">
<p class="ltx_p" id="A3.SS1.p19.1">Detection Opportunity</p>
</div>
<div class="ltx_para" id="A3.SS1.p20">
<p class="ltx_p" id="A3.SS1.p20.1">The attacker infrastructure leaks its configured hostname in RDP SSL certificates, which is identifiable in internet-wide scan data. This presents a detection opportunity for defenders – querying internet-wide scan data sources for an organization’s hostnames can uncover malicious IP addresses that may be masquerading as the organization. (Note: IP Scan history often shows IPs switching between default (WIN-*) hostnames and victim’s hostnames) Cross-referencing the list of IPs identified in internet scan data with remote access logs may identify evidence of this actor in an environment. There is likely to be a single account per IP address.</p>
</div>
<div class="ltx_para" id="A3.SS1.p21">
<p class="ltx_p" id="A3.SS1.p21.1">IP Addresses located in Victim’s Country</p>
</div>
<div class="ltx_para" id="A3.SS1.p22">
<p class="ltx_p" id="A3.SS1.p22.1">The attacker’s choice of IP addresses was also optimized to evade detection. The attacker primarily used only IP addresses originating from the same country as the victim, leveraging Virtual Private Servers.</p>
</div>
<div class="ltx_para" id="A3.SS1.p23">
<p class="ltx_p" id="A3.SS1.p23.1">Detection Opportunity</p>
</div>
<div class="ltx_para" id="A3.SS1.p24">
<p class="ltx_p" id="A3.SS1.p24.1">This also presents some detection opportunities, as geolocating IP addresses used for remote access may show an impossible rate of travel if a compromised account is being used by the legitimate user and the attacker from disparate IP addresses. The attacker used multiple IP addresses per VPS provider, so once a malicious login from an unusual ASN is identified, looking at all logins from that ASN can help detect additional malicious activity. This can be done alongside baselining and normalization of ASN’s used for legitimate remote access to help identify suspicious activity.</p>
</div>
<div class="ltx_para" id="A3.SS1.p25">
<p class="ltx_p" id="A3.SS1.p25.1">Lateral Movement Using Different Credentials</p>
</div>
<div class="ltx_para" id="A3.SS1.p26">
<p class="ltx_p" id="A3.SS1.p26.1">Once the attacker gained access to the network with compromised credentials, they moved laterally using multiple different credentials. The credentials used for lateral movement were always different from those used for remote access.</p>
</div>
<div class="ltx_para" id="A3.SS1.p27">
<p class="ltx_p" id="A3.SS1.p27.1">Detection Opportunity</p>
</div>
<div class="ltx_para" id="A3.SS1.p28">
<p class="ltx_p" id="A3.SS1.p28.1">Organizations can use HX’s LogonTracker module to graph all logon activity and analyze systems displaying a one-to-many relationship between source systems and accounts. This will uncover any single system authenticating to multiple systems with multiple accounts, a relatively uncommon occurrence during normal business operations.</p>
</div>
<div class="ltx_para" id="A3.SS1.p29">
<p class="ltx_p" id="A3.SS1.p29.1">Temporary File Replacement and Temporary Task Modification</p>
</div>
<div class="ltx_para" id="A3.SS1.p30">
<p class="ltx_p" id="A3.SS1.p30.1">The attacker used a temporary file replacement technique to remotely execute utilities: they replaced a legitimate utility with theirs, executed their payload, and then restored the legitimate original file. They similarly manipulated scheduled tasks by updating an existing legitimate task to execute their tools and then returning the scheduled task to its original configuration. They routinely removed their tools, including removing backdoors once legitimate remote access was achieved.</p>
</div>
<div class="ltx_para" id="A3.SS1.p31">
<p class="ltx_p" id="A3.SS1.p31.1">Detection Opportunity</p>
</div>
<div class="ltx_para" id="A3.SS1.p32">
<p class="ltx_p" id="A3.SS1.p32.1">Defenders can examine logs for SMB sessions that show access to legitimate directories and follow a delete-create-execute-delete-create pattern in a short amount of time. Additionally, defenders can monitor existing scheduled tasks for temporary updates, using frequency analysis to identify anomalous modification of tasks. Tasks can also be monitored to watch for legitimate Windows tasks executing new or unknown binaries.</p>
</div>
<div class="ltx_para" id="A3.SS1.p33">
<p class="ltx_p" id="A3.SS1.p33.1">This campaign’s post compromise activity was conducted with a high regard for operational security, in many cases leveraging dedicated infrastructure per intrusion. This is some of the best operational security that FireEye has observed in a cyber attack, focusing on evasion and leveraging inherent trust. However, it can be detected through persistent defense.</p>
</div>
<div class="ltx_para" id="A3.SS1.p34">
<p class="ltx_p" id="A3.SS1.p34.1">In-Depth Malware Analysis
SolarWinds.Orion.Core.BusinessLayer.dll (b91ce2fa41029f6955bff20079468448) is a SolarWinds-signed plugin component of the Orion software framework that contains an obfuscated backdoor which communicates via HTTP to third party servers. After an initial dormant period of up to two weeks, it retrieves and executes commands, called “Jobs”, that include the ability to transfer and execute files, profile the system, and disable system services. The backdoor’s behavior and network protocol blend in with legitimate SolarWinds activity, such as by masquerading as the Orion Improvement Program (OIP) protocol and storing reconnaissance results within plugin configuration files. The backdoor uses multiple blocklists to identify forensic and anti-virus tools via processes, services, and drivers.</p>
</div>
<div class="ltx_para" id="A3.SS1.p35">
<p class="ltx_p" id="A3.SS1.p35.1">Unique Capabilities
Subdomain DomainName Generation Algorithm (DGA) is performed to vary DNS requests
CNAME responses point to the C2 domain for the malware to connect to
The IP block of A record responses controls malware behavior
DGA encoded machine domain name, used to selectively target victims
Command and control traffic masquerades as the legitimate Orion Improvement Program
Code hides in plain site by using fake variable names and tying into legitimate components
Delivery and Installation
Authorized system administrators fetch and install updates to SolarWinds Orion via packages distributed by SolarWinds’s website. The update package CORE-2019.4.5220.20574-SolarWinds-Core-v2019.4.5220-Hotfix5.msp (02af7cec58b9a5da1c542b5a32151ba1) contains the SolarWinds.Orion.Core.BusinessLayer.dll described in this report. After installation, the Orion software framework executes the .NET program SolarWinds.BusinessLayerHost.exe to load plugins, including SolarWinds.Orion.Core.BusinessLayer.dll. This plugin contains many legitimate namespaces, classes, and routines that implement functionality within the Orion framework. Hidden in plain sight, the class SolarWinds.Orion.Core.BusinessLayer.
OrionImprovementBusinessLayer implements an HTTP-based backdoor. Code within the logically unrelated routine SolarWinds.Orion.Core.
BusinessLayer.BackgroundInventory.InventoryManager.RefreshInternal invokes the backdoor code when the Inventory Manager plugin is loaded.</p>
</div>
<div class="ltx_para" id="A3.SS1.p36">
<p class="ltx_p" id="A3.SS1.p36.1">SolarWinds.Orion.Core.BusinessLayer.dll is signed by SolarWinds, using the certificate with serial number 0f:e9:73:75:20:22:a6:06:ad:f2:a3:6e:
34:5d:c0:ed. The file was signed on March 24, 2020.</p>
</div>
<div class="ltx_para" id="A3.SS1.p37">
<p class="ltx_p" id="A3.SS1.p37.1">Initialization</p>
</div>
<div class="ltx_para" id="A3.SS1.p38">
<p class="ltx_p" id="A3.SS1.p38.1">On execution of the malicious SolarWinds.Orion.Core.BusinessLayer.
OrionImprovementBusinessLayer.Initialize method the sample verifies that its lower case process name hashes to the value 
<br class="ltx_break"/>17291806236368054941. This hash value is calculated as the standard FNV-1A 64-bit hash with an additional XOR by 6605813339339102567 after computing the FNV-1A. This hash matches a process named ”solarwinds.businesslayerhost”.</p>
</div>
<div class="ltx_para" id="A3.SS1.p39">
<p class="ltx_p" id="A3.SS1.p39.1">The sample only executes if the filesystem write time of the assembly is at least 12 to 14 days prior to the current time; the exact threshold is selected randomly from an interval. The sample continues to check this time threshold as it is run by a legitimate recurring background task. Once the threshold is met, the sample creates the named pipe 583da945-62af-10e8-4902-a8f205c72b2e to act as a guard that only one instance is running before reading SolarWinds.Orion.Core.BusinessLayer.dll.config from disk and retrieving the XML field appSettings. The appSettings fields’ keys are legitimate values that the malicious logic re-purposes as a persistent configuration. The key ReportWatcherRetry must be any value other than 3 for the sample to continue execution.</p>
</div>
<div class="ltx_para" id="A3.SS1.p40">
<p class="ltx_p" id="A3.SS1.p40.1">The sample checks that the machine is domain joined and retrieves the domain name before execution continues. A userID is generated by computing the MD5 of a network interface MAC address that is up and not a loopback device, the domain name, and the registry value HKEY_LOCAL_MACHINE
<br class="ltx_break"/>SOFTWARE
<br class="ltx_break"/>Microsoft
<br class="ltx_break"/>Cryptography
<br class="ltx_break"/>MachineGuid. The userID is encoded via a custom XOR scheme after the MD5 is calculated. The ReportWatcherPostpone key of appSettings is then read from SolarWinds.Orion.Core.BusinessLayer.dll.config to retrieve the initial, legitimate value. This operation is performed as the sample later bit packs flags into this field and the initial value must be known in order to read out the bit flags. The sample then invokes the method Update which is the core event loop of the sample.</p>
</div>
<div class="ltx_para" id="A3.SS1.p41">
<p class="ltx_p" id="A3.SS1.p41.1">DGA and Blocklists
The backdoor determines its C2 server using a Domain Generation Algorithm (DGA) to construct and resolve a subdomain of avsvmcloud[.]com. The Update method is responsible for initializing cryptographic helpers for the generation of these random C2 subdomains. Subdomains are generated by concatenating a victim userId with a reversible encoding of the victims local machine domain name. The attacker likely utilizes the DGA subdomain to vary the DNS response to victims as a means to control the targeting of the malware. These subdomains are concatenated with one of the following to create the hostname to resolve:</p>
</div>
<div class="ltx_para" id="A3.SS1.p42">
<p class="ltx_p" id="A3.SS1.p42.1">.appsync-api.eu-west-1[.]avsvmcloud[.]com
.appsync-api.us-west-2[.]avsvmcloud[.]com
.appsync-api.us-east-1[.]avsvmcloud[.]com
.appsync-api.us-east-2[.]avsvmcloud[.]com
Process name, service name, and driver path listings are obtained, and each value is hashed via the FNV-1a + XOR algorithm as described previously and checked against hardcoded blocklists. Some of these hashes have been brute force reversed as part of this analysis, showing that these routines are scanning for analysis tools and antivirus engine components. If a blocklisted process is found the Update routine exits and the sample will continue to try executing the routine until the blocklist passes. Blocklisted services are stopped by setting their HKLM
<br class="ltx_break"/>SYSTEM
<br class="ltx_break"/>CurrentControlSet
<br class="ltx_break"/>services
<br class="ltx_break"/>¡service_name¿
<br class="ltx_break"/>Start registry entries to value 4 for disabled. Some entries in the service list if found on the system may affect the DGA algorithms behavior in terms of the values generated. The list of stopped services is then bit-packed into the ReportWatcherPostpone key of the appSettings entry for the samples’ config file. If any service was transitioned to disabled the Update method exits and retries later. The sample retrieves a driver listing via the WMI query Select * From Win32_SystemDriver. If any blocklisted driver is seen the Update method exits and retries. If all blocklist tests pass, the sample tries to resolve api.solarwinds.com to test the network for connectivity.</p>
</div>
<div class="ltx_para" id="A3.SS1.p43">
<p class="ltx_p" id="A3.SS1.p43.1">Network Command and Control (C2)
If all blocklist and connectivity checks pass, the sample starts generating domains in a while loop via its DGA. The sample will delay for random intervals between the generation of domains; this interval may be any random value from the ranges 1 to 3 minutes, 30 to 120 minutes, or on error conditions up to 420 to 540 minutes (9 hours). The DNS A record of generated domains is checked against a hardcoded list of IP address blocks which control the malware’s behavior. Records within the following ranges will terminate the malware and update the configuration key ReportWatcherRetry to a value that prevents further execution:</p>
</div>
<div class="ltx_para" id="A3.SS1.p44">
<p class="ltx_p" id="A3.SS1.p44.1">10.0.0.0/8
172.16.0.0/12
192.168.0.0/16
224.0.0.0/3
fc00:: - fe00::
fec0:: - ffc0::
ff00:: - ff00::
20.140.0.0/15
96.31.172.0/24
131.228.12.0/22
144.86.226.0/24
Once a domain has been successfully retrieved in a CNAME DNS response the sample will spawn a new thread of execution invoking the method HttpHelper.Initialize which is responsible for all C2 communications and dispatching. The HTTP thread begins by delaying for a configurable amount of time that is controlled by the SetTime command. The HTTP thread will delay for a minimum of 1 minute between callouts. The malware uses HTTP GET or HTTP POST requests. If the sample is attempting to send outbound data the content-type HTTP header will be set to ”application/octet-stream” otherwise to ”application/json”.</p>
</div>
<div class="ltx_para" id="A3.SS1.p45">
<p class="ltx_p" id="A3.SS1.p45.1">A JSON payload is present for all HTTP POST and PUT requests and contains the keys “userId”, “sessionId”, and “steps”. The “steps” field contains a list of objects with the following keys: “Timestamp”, “Index”, “EventType”, “EventName”, “DurationMs”, “Succeeded”, and “Message”. The JSON key “EventType” is hardcoded to the value “Orion”, and the “EventName” is hardcoded to “EventManager”. Malware response messages to send to the server are DEFLATE compressed and single-byte-XOR encoded, then split among the “Message” fields in the “steps” array. Each “Message” value is Base64 encoded separately. Not all objects in the “steps” array contribute to the malware message – the integer in the “Timestamp” field must have the 0x2 bit set to indicate that the contents of the “Message” field are used in the malware message. Step objects whose bit 0x2 is clear in the Timestamp field contain random data and are discarded when assembling the malware response.</p>
</div>
<div class="ltx_para" id="A3.SS1.p46">
<p class="ltx_p" id="A3.SS1.p46.1">Steganography
In observed traffic these HTTP response bodies attempt to appear like benign XML related to .NET assemblies, but command data is actually spread across the many GUID and HEX strings present. Commands are extracted from HTTP response bodies by searching for HEX strings using the following regular expression: ”{[0-9a-f-]36}”—”[0-9a-f]32”—”[0-9a-f]16”. Command data is spread across multiple strings that are disguised as GUID and HEX strings. All matched substrings in the response are filtered for non HEX characters, joined together, and HEX-decoded. The first DWORD value shows the actual size of the message, followed immediately with the message, with optional additional junk bytes following. The extracted message is single-byte XOR decoded using the first byte of the message, and this is then DEFLATE decompressed. The first character is an ASCII integer that maps to the JobEngine enum, with optional additional command arguments delimited by space characters.</p>
</div>
<div class="ltx_para" id="A3.SS1.p47">
<p class="ltx_p" id="A3.SS1.p47.1">Commands are then dispatched to a JobExecutionEngine based upon the command value as described next.</p>
</div>
<div class="ltx_para" id="A3.SS1.p48">
<p class="ltx_p" id="A3.SS1.p48.1">Supported Commands
Command Value Operation
Idle 0 No operation
Exit 1 Terminate the current thread.
SetTime 2 Sets the delay time between main event loop executions Delay is in seconds, and varies random between [.9 * ¡delay¿, 1.1 * ¡delay¿]. If the delay is ¡ 300 it is doubled on the next execution through the loop, this means it should settle onto an interval of around [5, 10] minutes. There is a second, unrelated delay routine that delays for a random interval between [16hrs, 83hrs]
CollectSystemDescription 3 Profile the local system including hostname, username, OS version, MAC addresses, IP address, DHCP configuration, and domain information.
UploadSystemDescription 4 Perform a HTTP request to the specified URL, parse the results and compare components against unknown hashed values. Format a report and send to the C2 server.
RunTask 5 Starts a new process with the given file path and arguments
GetProcessByDescription 6 Returns a process listing. If no arguments are provided returns just the PID and process name. If an argument is provided it also returns the parent PID and username and domain for the process owner.</p>
</div>
<div class="ltx_para" id="A3.SS1.p49">
<p class="ltx_p" id="A3.SS1.p49.1">KillTask 7 Terminate the given process, by PID.
GetFileSystemEntries 8 Given a path and an optional match pattern recursively list files and directories
WriteFile 9 Given a file path and a Base64 encoded string write the contents of the Base64 decoded string to the given file path. Write using append mode. Delay for [1s, 2s] after writing is done.
FileExists 10 Tests whether the given file path exists.
DeleteFile 11 Deletes the specified file path.
GetFileHash 12 Compute the MD5 of a file at a given path and return result as a HEX string. If an argument is provided, it is the expected MD5 hash of the file and returns an error if the calculated MD5 differs.</p>
</div>
<div class="ltx_para" id="A3.SS1.p50">
<p class="ltx_p" id="A3.SS1.p50.1">ReadRegistryValue 13 Arbitrary registry read from one of the supported hives
SetRegistryValue 14 Arbitrary registry write from one of the supported hives.
DeleteRegistryValue 15 Arbitrary registry delete from one of the supported hives
GetRegistrySubKeyAndValueNames</p>
</div>
<div class="ltx_para" id="A3.SS1.p51">
<p class="ltx_p" id="A3.SS1.p51.1">16 Returns listing of subkeys and value names beneath the given registry path
Reboot 17 Attempts to immediately trigger a system reboot.
Indicators and Detections to Help the Community
To empower the community to detect this supply chain backdoor, we are publishing indicators and detections to help organizations identify this backdoor and this threat actor. The signatures are a mix of Yara, IOC, and Snort formats.</p>
</div>
<div class="ltx_para" id="A3.SS1.p52">
<p class="ltx_p" id="A3.SS1.p52.1">A list of the detections and signatures are available on the Mandiant GitHub repository. We are releasing detections and will continue to update the public repository with overlapping detections for host and network-based indicators as we develop new or refine existing ones. We have found multiple hashes with this backdoor and we will post updates of those hashes.</p>
</div>
<div class="ltx_para" id="A3.SS1.p53">
<p class="ltx_p" id="A3.SS1.p53.1">MITRE ATT&amp;CK Techniques Observed
ID Description
T1012 Query Registry
T1027 Obfuscated Files or Information
T1057 Process Discovery
T1070.004 File Deletion
T1071.001 Web Protocols
T1071.004 Application Layer Protocol: DNS
T1083 File and Directory Discovery
T1105 Ingress Tool Transfer
T1132.001 Standard Encoding
T1195.002 Compromise Software Supply Chain
T1518 Software Discovery
T1518.001 Security Software Discovery
T1543.003 Windows Service
T1553.002 Code Signing
T1568.002 Domain Generation Algorithms
T1569.002 Service Execution
T1584 Compromise Infrastructure
Immediate Mitigation Recommendations
Prior to following SolarWind’s recommendation to utilize Orion Platform release 2020.2.1 HF 1, which is currently available via the SolarWinds Customer Portal, organizations should consider preserving impacted devices and building new systems using the latest versions. Applying an upgrade to an impacted box could potentially overwrite forensic evidence as well as leave any additional backdoors on the system. In addition, SolarWinds has released additional mitigation and hardening instructions.</p>
</div>
<div class="ltx_para" id="A3.SS1.p54">
<p class="ltx_p" id="A3.SS1.p54.1">In the event you are unable to follow SolarWinds’ recommendations, the following are immediate mitigation techniques that could be deployed as first steps to address the risk of trojanized SolarWinds software in an environment. If attacker activity is discovered in an environment, we recommend conducting a comprehensive investigation and designing and executing a remediation strategy driven by the investigative findings and details of the impacted environment.</p>
</div>
<div class="ltx_para" id="A3.SS1.p55">
<p class="ltx_p" id="A3.SS1.p55.1">Ensure that SolarWinds servers are isolated / contained until a further review and investigation is conducted. This should include blocking all Internet egress from SolarWinds servers.
If SolarWinds infrastructure is not isolated, consider taking the following steps:
Restrict scope of connectivity to endpoints from SolarWinds servers, especially those that would be considered Tier 0 / crown jewel assets
Restrict the scope of accounts that have local administrator privileged on SolarWinds servers.
Block Internet egress from servers or other endpoints with SolarWinds software.
Consider (at a minimum) changing passwords for accounts that have access to SolarWinds servers / infrastructure. Based upon further review / investigation, additional remediation measures may be required.
If SolarWinds is used to managed networking infrastructure, consider conducting a review of network device configurations for unexpected / unauthorized modifications. Note, this is a proactive measure due to the scope of SolarWinds functionality, not based on investigative findings.</p>
</div>
</section>
<section class="ltx_subsection" id="A3.SS2">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">C.2. </span>Evasion Techniques</h3>
<div class="ltx_para" id="A3.SS2.p1">
<p class="ltx_p" id="A3.SS2.p1.1">Create an attack graph in json format using only nodes and edges as keys from the attack scenario given below. node should have id, label, edge should have from, to and label properties. Do not give a simplified graph. Add as much detail as possible. Incorporate all possible information in nodes and edges. Do not create separate keys for them in the json. Give only the graph in json format. Do not put text before or after json.</p>
</div>
<div class="ltx_para" id="A3.SS2.p2">
<p class="ltx_p" id="A3.SS2.p2.1">We are currently tracking the software supply chain compromise and related post intrusion activity as UNC2452. After gaining initial access, this group uses a variety of techniques to disguise their operations while they move laterally (Figure 2). This actor prefers to maintain a light malware footprint, instead preferring legitimate credentials and remote access for access into a victim’s environment. Post-compromise tactics TEARDROP and BEACON Malware Used Multiple SUNBURST samples have been recovered, delivering different payloads. In at least one instance the attackers deployed a previously unseen memory-only dropper we’ve dubbed TEARDROP to deploy Cobalt Strike BEACON. TEARDROP is a memory only dropper that runs as a service, spawns a thread and reads from the file “gracious_truth.jpg”, which likely has a fake JPG header. Next it checks that HKU
<br class="ltx_break"/>SOFTWARE
<br class="ltx_break"/>Microsoft
<br class="ltx_break"/>CTF exists, decodes an embedded payload using a custom rolling XOR algorithm and manually loads into memory an embedded payload using a custom PE-like file format. TEARDROP does not have code overlap with any previously seen malware. We believe that this was used to execute a customized Cobalt Strike BEACON. Attacker Hostnames Match Victim Environment The actor sets the hostnames on their command and control infrastructure to match a legitimate hostname found within the victim’s environment. This allows the adversary to blend into the environment, avoid suspicion, and evade detection. IP Addresses located in Victim’s Country The attacker’s choice of IP addresses was also optimized to evade detection. The attacker primarily used only IP addresses originating from the same country as the victim, leveraging Virtual Private Servers. Lateral Movement Using Different Credentials Once the attacker gained access to the network with compromised credentials, they moved laterally using multiple different credentials. The credentials used for lateral movement were always different from those used for remote access. Temporary File Replacement and Temporary Task Modification The attacker used a temporary file replacement technique to remotely execute utilities: they replaced a legitimate utility with theirs, executed their payload, and then restored the legitimate original file. They similarly manipulated scheduled tasks by updating an existing legitimate task to execute their tools and then returning the scheduled task to its original configuration. They routinely removed their tools, including removing backdoors once legitimate remote access was achieved.</p>
</div>
</section>
</section>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Sun Aug 11 19:57:54 2024 by <a class="ltx_LaTeXML_logo" href="http://dlmf.nist.gov/LaTeXML/"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img alt="Mascot Sammy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg=="/></a>
</div></footer>
</div>
</body>
</html>
